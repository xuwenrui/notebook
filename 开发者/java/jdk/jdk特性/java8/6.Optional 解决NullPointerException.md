[`Tired of Null Pointer Exceptions? Consider Using Java SE 8's "Optional"!`](https://www.oracle.com/technical-resources/articles/java/java8-optional.html#:~:text=If%20soundcard%20were%20null%2C%20a%20NullPointerException%20would%20be,hold%20a%20null%20value%3A%20Optional%3CSoundcard%3E%20sc%20%3D%20Optional.ofNullable%28soundcard%29%3B)
**使您的代码更具可读性，并防止其出现空指针异常。**

一位智者曾经说过，如果你没有处理过空指针异常，你就不算是一个真正的 Java 程序员。玩笑归玩笑，空引用是许多问题的根源，因为它通常用于表示值的缺失。Java SE 8 引入了一个名为 的新类，`java.util.Optional`它可以缓解其中一些问题。

让我们先从一个例子开始，看看 null 的危险。让我们考虑一个嵌套的对象结构`Computer`，如图 1 所示。

![java8-可选-f1](https://www.oracle.com/img/tech/java8-optional-f1.gif)

**图 1：表示`Computer`**

以下代码可能存在什么问题？

`String version = computer.getSoundcard().getUSB().getVersion();`

这段代码看起来非常合理。但是，许多计算机（例如 Raspberry Pi）实际上并没有配备声卡。那么 的结果是什么`getSoundcard()`？

一种常见的（不好的）做法是返回空引用以指示没有声卡。不幸的是，这意味着对的调用`getUSB()`将尝试返回空引用的 USB 端口，这将导致`NullPointerException`运行时并停止程序的进一步运行。想象一下，如果您的程序正在客户的机器上运行；如果程序突然失败，您的客户会怎么说？

为了提供一些历史背景，计算机科学巨头之一托尼·霍尔写道：“我称其为我价值数十亿美元的错误。这是 1965 年发明的空引用。我无法抗拒插入空引用的诱惑，只是因为它太容易实现。”

如何防止意外的空指针异常？您可以采取预防措施并添加检查以防止空引用，如清单 1 所示：

复制

已复制到剪贴板

错误：无法复制

```java
String version = "UNKNOWN";
if(computer != null){
  Soundcard soundcard = computer.getSoundcard();
  if(soundcard != null){
    USB usb = soundcard.getUSB();
    if(usb != null){
      version = usb.getVersion();
    }
  }
}
```

**清单 1**

但是，您可以看到，由于嵌套检查，清单 1 中的代码很快变得非常丑陋。不幸的是，我们需要大量的样板代码来确保我们不会得到`NullPointerException`。此外，这些检查妨碍了业务逻辑，这很烦人。事实上，它们降低了我们程序的整体可读性。

此外，这是一个容易出错的过程；如果你忘记检查一个属性是否为空，该怎么办？我将在本文中论证，使用 null 来表示值的缺失是一种错误的方法。我们需要的是一种更好的方法来模拟值的缺失和存在。

为了提供一些背景信息，让我们简单看一下其他编程语言所提供的功能。

#### 有哪些 Null 的替代方案？

Groovy 等语言具有一个由“ ”表示的_安全导航运算符_`?.`，可以安全地浏览潜在的空引用。（请注意，它也很快将包含在 C# 中，并且它被提议用于 Java SE 7，但未包含在该版本中。）它的工作原理如下：

`String version = computer?.getSoundcard()?.getUSB()?.getVersion();`

在这种情况下，如果变量为 null，`version`则将其赋值为 null `computer`，否则`getSoundcard()`返回 null，否则`getUSB()`返回 null。您无需编写复杂的嵌套条件来检查是否为 null。

此外，Groovy 还包含_Elvis 运算符_“ `?:`”（如果您从侧面看，就会认出 Elvis 著名的发型），可用于需要默认值的简单情况。在下面，如果使用安全导航运算符的表达式返回 null，则`"UNKNOWN"`返回默认值；否则，返回可用的版本标记。

复制

已复制到剪贴板

错误：无法复制

```java
String version = 
    computer?.getSoundcard()?.getUSB()?.getVersion() ?: "UNKNOWN";
```

其他函数式语言（如 Haskell 和 Scala）则持不同观点。Haskell 包含一个`Maybe`类型，它本质上封装了一个可选值。类型的值`Maybe`可以包含给定类型的值，也可以不包含任何值。没有空引用的概念。Scala 有一个类似的构造，称为`Option[T]`，用于封装类型值的存在或不存在`T`。然后，您必须使用类型上可用的操作明确检查值是否存在`Option`，这强制执行了“空检查”的概念。您再也不能“忘记做这件事”了，因为它是由类型系统强制执行的。

好吧，我们有点分歧，这一切听起来相当抽象。你现在可能会想，“那么，Java SE 8 呢？”

#### `Optional`简而言之

Java SE 8 引入了一个名为 j 的新类`ava.util.Optional<T>`，其灵感来自 Haskell 和 Scala 的思想。它是一个封装可选值的类，如下面的清单 2 和图 1 所示。您可以将其视为`Optional`一个单值容器，它要么包含值，要么不包含值（则称为“空”），如图 2 所示。

![java8-可选-f2](https://www.oracle.com/img/tech/java8-optional-f2.gif)

**图 2：可选声卡**

我们可以更新我们的模型来利用`Optional`，如清单 2 所示：

复制

已复制到剪贴板

错误：无法复制

```java
public class Computer {
  private Optional<Soundcard> soundcard;  
  public Optional<Soundcard> getSoundcard() { ... }
  ...
}

public class Soundcard {
  private Optional<USB> usb;
  public Optional<USB> getUSB() { ... }

}

public class USB{
  public String getVersion(){ ... }
}
```

**清单 2**

清单 2 中的代码立即表明计算机可能有或可能没有声卡（声卡是可选的）。此外，声卡可以选择有一个 USB 端口。这是一个改进，因为这个新模型现在可以清楚地反映给定值是否允许缺失。请注意，类似的想法在 Guava 等库中已经存在。

但是您实际上可以用对象做什么呢`Optional<Soundcard>`？毕竟，您想要获取 USB 端口的版本号。简而言之，该类`Optional`包含明确处理值存在或不存在的情况的方法。但是，与空引用相比，该类的优势在于，`Optional`当值不存在时，它会迫使您考虑这种情况。因此，您可以防止意外的空指针异常。

需要注意的是，该类的目的`Optional`不是替换每个空引用。相反，它的目的是帮助设计更易于理解的 API，这样只需阅读方法的签名，就可以判断是否可以期待一个可选值。这迫使您主动解包`Optional`以处理缺少值的情况。

#### 采用的模式`Optional`

说得够多了；让我们看一些代码！我们将首先探讨如何使用 重写典型的空检查模式`Optional`。在本文结束时，您将了解如何使用`Optional`重写清单 1 中执行多个嵌套空检查的代码（如下所示）：

复制

已复制到剪贴板

错误：无法复制

```java
String name = computer.flatMap(Computer::getSoundcard)
                          .flatMap(Soundcard::getUSB)
                          .map(USB::getVersion)
                          .orElse("UNKNOWN");
```

**注意**：请务必复习 Java SE 8 lambda 和方法引用语法（参见“ [Java 8：Lambdas](https://www.oracle.com/technical-resources/articles/java/architect-lambdas-part1.html) ”）及其流管道概念（参见“使用 Java SE 8 流处理数据”）。

#### 创建`Optional`对象

首先，如何创建`Optional`对象？有几种方法：

这是一个空的`Optional`：

`Optional<Soundcard> sc = Optional.empty();`

这是一个`Optional`非空值：

复制

已复制到剪贴板

错误：无法复制

```java
SoundCard soundcard = new Soundcard();
Optional<Soundcard> sc = Optional.of(soundcard);
```

如果`soundcard`为空，`NullPointerException`则会立即抛出（而不是在您尝试访问的属性时出现潜在错误`soundcard`）。

此外，通过使用`ofNullable`，您可以创建一个`Optional`可能包含空值的对象：

`Optional<Soundcard> sc = Optional.ofNullable(soundcard);`

如果声卡为空，则生成的`Optional`对象将为空。

#### 如果存在值则执行某些操作

现在您有了一个`Optional`对象，您可以访问可用的方法来明确处理值的存在或不存在。 而不必记住进行空值检查，如下所示：

复制

已复制到剪贴板

错误：无法复制

```java
SoundCard soundcard = ...;
if(soundcard != null){
  System.out.println(soundcard);
}
```

您可以使用该`ifPresent()`方法，如下所示：

复制

已复制到剪贴板

错误：无法复制

```java
Optional<Soundcard> soundcard = ...;
soundcard.ifPresent(System.out::println);
```

您不再需要进行显式的空值检查；它由类型系统强制执行。如果对象`Optional`为空，则不会打印任何内容。

您还可以使用`isPresent()`方法来查明`Optional`对象中是否存在某个值。此外，如果对象`get()`中存在某个值，则还有一种方法返回该值。否则，它会抛出。可以组合这两种方法来防止出现异常，如下所示：`Optional``NoSuchElementException`

复制

已复制到剪贴板

错误：无法复制

```java
if(soundcard.isPresent()){
  System.out.println(soundcard.get());
}
```

但是，这不是推荐的用法`Optional`（它与嵌套的空检查相比并没有太大的改进），并且还有更多惯用的替代方法，我们将在下面进行探讨。

#### 默认值和操作

一种典型的模式是，如果确定操作结果为空，则返回默认值。通常，可以使用三元运算符来实现这一点，如下所示：

复制

已复制到剪贴板

错误：无法复制

```java
Soundcard soundcard = 
  maybeSoundcard != null ? maybeSoundcard 
            : new Soundcard("basic_sound_card");
```

使用`Optional`对象，您可以使用该`orElse()`方法重写此代码，如果为空，则提供默认值`Optional`：

`Soundcard soundcard = maybeSoundcard.orElse(new Soundcard("defaut"));`

类似地，您可以使用该方法，如果为空，则抛出异常，`orElseThrow()`而不是提供默认值：`Optional`

复制

已复制到剪贴板

错误：无法复制

```java
Soundcard soundcard = 
  maybeSoundCard.orElseThrow(IllegalStateException::new);
```

#### `filter`使用该方法拒绝某些值

通常，您需要调用对象上的方法并检查某些属性。例如，您可能需要检查 USB 端口是否为特定版本。为了安全地执行此操作，您首先需要检查指向 USB 对象的引用是否为空，然后调用该`getVersion()`方法，如下所示：

复制

已复制到剪贴板

错误：无法复制

```java
USB usb = ...;
if(usb != null && "3.0".equals(usb.getVersion())){
  System.out.println("ok");
}
```

可以使用对象`filter`上的方法重写此模式`Optional`，如下所示：

复制

已复制到剪贴板

错误：无法复制

```java
Optional<USB> maybeUSB = ...;
maybeUSB.filter(usb -> "3.0".equals(usb.getVersion())
                    .ifPresent(() -> System.out.println("ok"));
```

该`filter`方法将谓词作为参数。如果对象中存在值`Optional`并且该值与谓词匹配，则该`filter`方法返回该值；否则，它将返回一个空对象。如果您已将该方法与接口一起`Optional`使用，您可能已经看到过类似的模式。`filter``Stream`

#### `map`使用方法提取和转换值

另一种常见模式是从对象中提取信息。例如，`Soundcard`您可能希望从对象中提取该`USB`对象，然后进一步检查其是否为正确的版本。您通常会编写以下代码：

复制

已复制到剪贴板

错误：无法复制

```java
if(soundcard != null){
  USB usb = soundcard.getUSB();
  if(usb != null && "3.0".equals(usb.getVersion()){
    System.out.println("ok");
  }
}
```

我们可以使用该方法重写这种“检查是否为空并提取”（此处为对象`Soundcard`）的模式`map`。

`Optional<USB> usb = maybeSoundcard.map(Soundcard::getUSB);`

这与流中使用的方法直接相似`map`。在那里，您将一个函数传递给该`map`方法，该方法将此函数应用于流的每个元素。但是，如果流为空，则不会发生任何事情。

`map`类的方法的作用`Optional`完全相同：内部包含的值`Optional`由作为参数传递的函数“转换”（此处为提取 USB 端口的方法引用），而如果`Optional`为空则什么也不会发生。

最后，我们可以将该`map`方法与`filter`拒绝版本不同于 3.0 的 USB 端口的方法结合起来：

复制

已复制到剪贴板

错误：无法复制

```java
maybeSoundcard.map(Soundcard::getUSB)
      .filter(usb -> "3.0".equals(usb.getVersion())
      .ifPresent(() -> System.out.println("ok"));
```

太棒了；我们的代码开始更接近问题陈述，并且没有冗长的空检查妨碍我们！

#### `Optional`使用`flatMap`方法级联对象

您已经看到了一些可以重构使用的模式`Optional`。那么我们如何才能安全地编写以下代码？

`String version = computer.getSoundcard().getUSB().getVersion();`

请注意，此代码所做的只是从另一个对象中提取一个对象，这正是该`map`方法的用途。在本文前面，我们更改了模型，因此 a`Computer`有一个`Optional<Soundcard>`， a`Soundcard`有一个`Optional<USB>`，因此我们应该能够编写以下内容：

复制

已复制到剪贴板

错误：无法复制

```java
String version = computer.map(Computer::getSoundcard)
                  .map(Soundcard::getUSB)
                  .map(USB::getVersion)
                  .orElse("UNKNOWN");
```

不幸的是，这段代码无法编译。为什么？变量 computer 的类型为`Optional<Computer>`，因此调用该`map`方法完全正确。但是，`getSoundcard()`返回 类型的对象`Optional<Soundcard>`。这意味着 map 操作的结果是一个 类型的对象`Optional<Optional<Soundcard>>`。因此，对 的调用`getUSB()`是无效的，因为最外层`Optional`包含 another 作为其值`Optional`，而后者当然不支持该方法。图 3 说明了您将获得的`getUSB()`嵌套结构。`Optional`

![java8-可选-f3](https://www.oracle.com/img/tech/java8-optional-f3.gif)

**图 3：两级`Optional`**

那么我们如何解决这个问题呢？再次，我们可以看看您以前可能在流中使用过的一种模式：方法`flatMap`。对于流，`flatMap`方法将一个函数作为参数，该函数返回另一个流。此函数应用于流的每个元素，这将产生一个流的流。但是，其`flatMap`效果是将每个生成的流替换为该流的内容。换句话说，函数生成的所有单独流都会合并或“扁平化”为一个流。我们在这里想要的是类似的东西，但我们希望将两级“扁平化”为一级`Optional`。

好吧，这里有个好消息：`Optional`还支持一种`flatMap`方法。其目的是将转换函数应用于 的值`Optional`（就像 map 操作一样），然后将得到的两级展开为一个级。图 4 说明了转换函数返回对象时和`Optional`之间的区别。`map``flatMap``Optional`

![java8-可选-f4](https://www.oracle.com/img/tech/java8-optional-f4.gif)

**图 4：使用`map`versus`flatMap``Optional`**

因此，为了使我们的代码正确，我们需要使用以下命令重写它`flatMap`：

复制

已复制到剪贴板

错误：无法复制

```java
String version = computer.flatMap(Computer::getSoundcard)
                   .flatMap(Soundcard::getUSB)
                   .map(USB::getVersion)
                   .orElse("UNKNOWN");
```

第一个`flatMap`确保`Optional<Soundcard>`返回一个而不是一个`Optional<Optional<Soundcard>>`，第二个`flatMap`实现相同的目的，返回一个`Optional<USB>`。请注意，第三个调用只需要是一个，`map()`因为`getVersion()`返回一个`String`而不是一个`Optional`对象。