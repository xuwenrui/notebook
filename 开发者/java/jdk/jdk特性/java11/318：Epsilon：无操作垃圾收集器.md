Java 11引入了一个实验性的垃圾收集器——Epsilon，它被称为“无操作”（No-Op）垃圾收集器。Epsilon的设计理念非常独特，它的核心特点是不做任何实际的垃圾回收工作，也就是说，它不会试图去释放不再使用的内存空间。这种设计听起来可能违背直觉，但实际上，Epsilon有其特定的应用场景和目的：

1. **测试与分析**: Epsilon可以用于性能测试和分析，因为它完全不执行垃圾回收，可以消除垃圾收集对测试结果的影响，帮助开发者准确地衡量应用程序本身的性能，而不受垃圾收集周期的干扰。这对于评估应用程序的内存泄漏、分配速率等特性特别有用。
    
2. **一次性应用程序**: 对于那些运行后立即退出、并且内存使用量可预测且不大的应用程序，Epsilon可以作为一种简单的内存管理策略。因为在这种情况下，内存清理可以在程序结束时由操作系统处理，而不需要垃圾收集器介入。
    
3. **嵌入式系统**: 在资源极其有限或者对实时性要求极高的嵌入式系统中，Epsilon可以作为一种简化方案，避免垃圾收集带来的不确定延迟。
    
4. **教学与研究**: 它也是教学和研究的理想工具，帮助理解没有垃圾回收机制时系统的行为，以及如何手动管理内存。
    

需要注意的是，使用Epsilon意味着程序必须严格控制自己的内存使用，避免耗尽所有可用内存。由于Epsilon不进行垃圾回收，一旦内存耗尽，程序很可能会崩溃或受到操作系统级别的内存管理干预（如段错误或内存不足错误）。

启用Epsilon垃圾收集器通常通过设置JVM启动参数实现，例如：`-XX:+UseEpsilonGC`。但因为它是实验性质的，所以在生产环境中部署前需要仔细考虑其潜在风险和适用性。