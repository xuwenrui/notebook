
```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
   <groupId>org.apache.commons</groupId>
   <artifactId>commons-pool2</artifactId>
</dependency>
```
SpringBoot 2.0发布以来，默认使用的是Lettuce

●Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的，其API也是线程安全的，因此多个线程可以操作单个Lettuce连接来完成各种操作，并且Lettuce支持连接池。Lettuce线程可以被多个请求公用，且不会产生频繁创建和关闭Lettuce连接的开销,因此比较适合应用于高并发网站。

●Jedis是同步的，不支持异步，Jedis客户端连接不是线程安全的，需要为每个请求创建和关闭一个Jedis连接，所以一般通过连接池来使用Jedis客户端连接。Jedis不太适合在高并发网站使用，当遇到高并发场景时，Jedis连接池无法避免频繁创建和关闭Jedis连接，因为这会造成十分大的系统开销。
![[Pasted image 20240827085946.png]]

```java
package com.learn.chapter7.cfg;
　
/**** imports ****/
@Configuration
public class RedisConfig {
　
   // 创建Redis连接工厂
   @Bean(name = "RedisConnectionFactory")
   public RedisConnectionFactory initRedisConnectionFactory() {
      // Redis配置
      var redisCfg = new RedisStandaloneConfiguration("192.168.80.137", 6379);
      // 设置密码
      redisCfg.setPassword("abcdefg");
      // 配置连接池
      var poolConfig = new GenericObjectPoolConfig<Object>();
      // 最大空闲数
      poolConfig.setMaxIdle(30);
      // 最大连接数
      poolConfig.setMaxTotal(50);
      // Lettuce连接池客户端配置，这里使用建造者模式
      var lettuceCfg = LettucePoolingClientConfiguration.builder()
             .commandTimeout(Duration.ofSeconds(2)) // 命令超时时间为2s
             .poolConfig(poolConfig) // 配置连接池
             .build(); // 创建配置
      // 创建连接工厂
      var connectionFactory = new LettuceConnectionFactory(redisCfg, lettuceCfg);
      return connectionFactory;
   }
　
}
```

#### RedisTemplate和StringRedisTemplate
RedisTemplate和StringRedisTemplate都是常用的类，因此它们也是Spring操作Redis的主要方式。StringRedisTemplate是RedisTemplate的子类，从名称就可以看出，StringRedisTemplate专门用于操作字符串。
```java
// 创建RedisTemplate
@Bean(name="redisTemplate")
public RedisTemplate<Object, Object> initRedisTemplate(
      @Autowired RedisConnectionFactory redisConnectionFactory) {
   var redisTemplate = new RedisTemplate<Object, Object>();
   // 设置Redis连接工厂
   redisTemplate.setConnectionFactory(redisConnectionFactory);
   return redisTemplate;
}
```

测试RedisTemplate
```java
package com.learn.chapter7.main;
/**** imports ****/
public class RedisMain {
   public static void main(String[] args) {
      // 创建IoC容器
      var ctx = new AnnotationConfigApplicationContext(RedisConfig.class);
      try {
         // 获取RedisTemplate
         var redisTemplate = ctx.getBean(RedisTemplate.class);
         // 执行Redis命令
         redisTemplate.opsForValue().set("key1", "value1");
         redisTemplate.opsForHash().put("hash", "field", "hvalue");
      } finally {
         ctx.close(); // 关闭IoC容器
      }
   }
}
```
Spring提供了RedisSerializer接口。该接口定义了两个方法：一个是serialize()，它能把那些可以序列化的对象转换为序列化后的字符串；另一个是deserialize()，它能够通过反序列化把序列化后的字符串转换为Java对象。这里主要讨论最常用的两种序列化器—— StringRedisSerializer和JdkSerializationRedisSerializer，其中JdkSerializationRedisSerializer是RedisTemplate默认的序列化器
![[Pasted image 20240827090423.png]]
![[Pasted image 20240827090455.png]]

###### 使用字符串序列化器
```java
// 创建RedisTemplate
@Bean(name="redisTemplate")
public RedisTemplate<Object, Object> initRedisTemplate(
      @Autowired RedisConnectionFactory redisConnectionFactory) {
   var redisTemplate = new RedisTemplate<Object, Object>();
   redisTemplate.setConnectionFactory(redisConnectionFactory);
   // Redis键序列化器设置为StringRedisSerializer
   redisTemplate.setKeySerializer(RedisSerializer.string());
   // Redis哈希键序列化器设置为StringRedisSerializer
   redisTemplate.setHashKeySerializer(RedisSerializer.string());
   // Redis值序列化器设置为JdkSerializationRedisSerializer
   redisTemplate.setValueSerializer(RedisSerializer.java());
   // Redis哈希值序列化器设置为JdkSerializationRedisSerializer
   redisTemplate.setHashValueSerializer(RedisSerializer.java());
   return redisTemplate;
}
```

#### Spring对Redis数据类型操作的封装
```
// 获取字符串操作接口
redisTemplate.opsForValue();
// 获取哈希操作接口
redisTemplate.opsForHash();
// 获取列表（链表）操作接口
redisTemplate.opsForList();
// 获取集合操作接口
redisTemplate.opsForSet();
// 获取有序集合操作接口
redisTemplate.opsForZSet();
```