
```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
   <groupId>org.apache.commons</groupId>
   <artifactId>commons-pool2</artifactId>
</dependency>
```
SpringBoot 2.0发布以来，默认使用的是Lettuce

●Lettuce是基于Netty框架的事件驱动的Redis客户端，其方法调用是异步的，其API也是线程安全的，因此多个线程可以操作单个Lettuce连接来完成各种操作，并且Lettuce支持连接池。Lettuce线程可以被多个请求公用，且不会产生频繁创建和关闭Lettuce连接的开销,因此比较适合应用于高并发网站。

●Jedis是同步的，不支持异步，Jedis客户端连接不是线程安全的，需要为每个请求创建和关闭一个Jedis连接，所以一般通过连接池来使用Jedis客户端连接。Jedis不太适合在高并发网站使用，当遇到高并发场景时，Jedis连接池无法避免频繁创建和关闭Jedis连接，因为这会造成十分大的系统开销。
![[Pasted image 20240827085946.png]]

```java
package com.learn.chapter7.cfg;
　
/**** imports ****/
@Configuration
public class RedisConfig {
　
   // 创建Redis连接工厂
   @Bean(name = "RedisConnectionFactory")
   public RedisConnectionFactory initRedisConnectionFactory() {
      // Redis配置
      var redisCfg = new RedisStandaloneConfiguration("192.168.80.137", 6379);
      // 设置密码
      redisCfg.setPassword("abcdefg");
      // 配置连接池
      var poolConfig = new GenericObjectPoolConfig<Object>();
      // 最大空闲数
      poolConfig.setMaxIdle(30);
      // 最大连接数
      poolConfig.setMaxTotal(50);
      // Lettuce连接池客户端配置，这里使用建造者模式
      var lettuceCfg = LettucePoolingClientConfiguration.builder()
             .commandTimeout(Duration.ofSeconds(2)) // 命令超时时间为2s
             .poolConfig(poolConfig) // 配置连接池
             .build(); // 创建配置
      // 创建连接工厂
      var connectionFactory = new LettuceConnectionFactory(redisCfg, lettuceCfg);
      return connectionFactory;
   }
　
}
```

#### RedisTemplate和StringRedisTemplate
RedisTemplate和StringRedisTemplate都是常用的类，因此它们也是Spring操作Redis的主要方式。StringRedisTemplate是RedisTemplate的子类，从名称就可以看出，StringRedisTemplate专门用于操作字符串。
```java
// 创建RedisTemplate
@Bean(name="redisTemplate")
public RedisTemplate<Object, Object> initRedisTemplate(
      @Autowired RedisConnectionFactory redisConnectionFactory) {
   var redisTemplate = new RedisTemplate<Object, Object>();
   // 设置Redis连接工厂
   redisTemplate.setConnectionFactory(redisConnectionFactory);
   return redisTemplate;
}
```

测试RedisTemplate
```java
package com.learn.chapter7.main;
/**** imports ****/
public class RedisMain {
   public static void main(String[] args) {
      // 创建IoC容器
      var ctx = new AnnotationConfigApplicationContext(RedisConfig.class);
      try {
         // 获取RedisTemplate
         var redisTemplate = ctx.getBean(RedisTemplate.class);
         // 执行Redis命令
         redisTemplate.opsForValue().set("key1", "value1");
         redisTemplate.opsForHash().put("hash", "field", "hvalue");
      } finally {
         ctx.close(); // 关闭IoC容器
      }
   }
}
```
Spring提供了RedisSerializer接口。该接口定义了两个方法：一个是serialize()，它能把那些可以序列化的对象转换为序列化后的字符串；另一个是deserialize()，它能够通过反序列化把序列化后的字符串转换为Java对象。这里主要讨论最常用的两种序列化器—— StringRedisSerializer和JdkSerializationRedisSerializer，其中JdkSerializationRedisSerializer是RedisTemplate默认的序列化器
![[Pasted image 20240827090423.png]]
![[Pasted image 20240827090455.png]]

###### 使用字符串序列化器
```java
// 创建RedisTemplate
@Bean(name="redisTemplate")
public RedisTemplate<Object, Object> initRedisTemplate(
      @Autowired RedisConnectionFactory redisConnectionFactory) {
   var redisTemplate = new RedisTemplate<Object, Object>();
   redisTemplate.setConnectionFactory(redisConnectionFactory);
   // Redis键序列化器设置为StringRedisSerializer
   redisTemplate.setKeySerializer(RedisSerializer.string());
   // Redis哈希键序列化器设置为StringRedisSerializer
   redisTemplate.setHashKeySerializer(RedisSerializer.string());
   // Redis值序列化器设置为JdkSerializationRedisSerializer
   redisTemplate.setValueSerializer(RedisSerializer.java());
   // Redis哈希值序列化器设置为JdkSerializationRedisSerializer
   redisTemplate.setHashValueSerializer(RedisSerializer.java());
   return redisTemplate;
}
```

#### Spring对Redis数据类型操作的封装
```
// 获取字符串操作接口
redisTemplate.opsForValue();
// 获取哈希操作接口
redisTemplate.opsForHash();
// 获取列表（链表）操作接口
redisTemplate.opsForList();
// 获取集合操作接口
redisTemplate.opsForSet();
// 获取有序集合操作接口
redisTemplate.opsForZSet();



// 获取字符串绑定键操作接口
redisTemplate.boundValueOps("string");
// 获取哈希绑定键操作接口
redisTemplate.boundHashOps("hash");
// 获取列表（链表）绑定键操作接口
redisTemplate.boundListOps("list");
// 获取集合绑定键操作接口
redisTemplate.boundSetOps("set");
// 获取有序集合绑定键操作接口
redisTemplate.boundZSetOps("zset");
```

#### SessionCallback和RedisCallback接口
```java
public void useSessionCallback(RedisTemplate redisTemplate) { // SessionCallback接口
   var sessionCallback = new SessionCallback<Object>() {
      @Override
      public Object execute(RedisOperations operations) throws DataAccessException {
         operations.opsForValue().set("key1", "value1");
         operations.opsForHash().put("hash", "field", "hvalue");
         return null;
      }
   };
   redisTemplate.execute(sessionCallback);
}
　
public void useRedisCallback(RedisTemplate redisTemplate) { // RedisCallback接口
   redisTemplate.execute((RedisConnection rc) -> {
      rc.stringCommands().set("key1".getBytes(), "value1".getBytes());
      rc.hashCommands().hSet("hash".getBytes(),
            "field".getBytes(), "hvalue".getBytes());
      return null;
   });
}
```

#### 在Spring Boot中配置和操作Redis
```
######## 配置Redis服务器属性 ########
spring.data.redis.port=6379
# 服务器IP
spring.data.redis.host=192.168.80.137
# 密码
spring.data.redis.password=abcdefg
# Redis连接超时时间为30 s
spring.data.redis.timeout=30s
　
######## 配置连接池属性（需依赖commons-pool2包） ########
# 最小空闲连接数，默认为0
spring.data.redis.lettuce.pool.min-idle=5
# 最大活动连接数，默认为8
spring.data.redis.lettuce.pool.max-active=15
# 最大空闲连接数，默认为8
spring.data.redis.lettuce.pool.max-idle=10
# 最大阻塞等待时间，默认为-1ms，表示无限等待
spring.data.redis.lettuce.pool.max-wait=5s
```

##### 修改RedisTemplate的序列化器
```java
package com.learn.chapter7.main;
　
/**** imports ****/
@SpringBootApplication(scanBasePackages = "com.learn.chapter7")
public class Chapter7Application implements ApplicationContextAware {
   // 设置RedisTemplate的序列化器
   private void initRedisTemplate(RedisTemplate redisTemplate) {
      var stringSerializer = RedisSerializer.string();
      // 键
      redisTemplate.setKeySerializer(stringSerializer);
      // 哈希键
      redisTemplate.setHashKeySerializer(stringSerializer);
   }
   @Override
   public void setApplicationContext(ApplicationContext applicationContext)
         throws BeansException {
      /**
       *  从IoC容器中取出RedisTemplate，但Spring Boot会同时初始化StringRedisTemplate
       *  而StringRedisTemplate是RedisTemplate的子类，因此需要通过名称获取Bean
       */
      var redisTemplate = applicationContext
             .getBean("redisTemplate", RedisTemplate.class); // ①
      this.initRedisTemplate(redisTemplate);
   }
   ......
}
```

##### 操作Redis数据类型
```java
package com.learn.chapter7.main;
　
/**** imports ****/
　
@Component
public class RedisTest {
   // 注入RedisTemplate
   @Autowired
   private RedisTemplate redisTemplate = null;
   // 注入StringRedisTemplate
   @Autowired
   private StringRedisTemplate stringRedisTemplate = null;
   @PostConstruct // 声明为构建对象后运行的方法，这样Spring Boot会自动调用它
   public void testRedis() {
      testStringAndHash();
   }
   private void testStringAndHash() {
      redisTemplate.opsForValue().set("key1", "value1");
      // 注意，这里使用了JDK序列化器，所以Redis保存的键不是整数，不能运算
      redisTemplate.opsForValue().set("int_key", "1");
      stringRedisTemplate.opsForValue().set("int", "1");
      // 使用运算
      stringRedisTemplate.opsForValue().increment("int", 1);
      // 获取底层连接
      var commands = (RedisAsyncCommands) stringRedisTemplate.getConnectionFactory()
               .getConnection().getNativeConnection();
      // 减1运算，RedisTemplate不支持这个命令，所以先获取底层的连接再操作
      commands.decr("int");
      // 关闭连接
      commands.quit();
      var hash = new HashMap<String, String>();
      hash.put("field1", "value1");
      hash.put("field2", "value2");
      // 存入一个哈希数据类型
      stringRedisTemplate.opsForHash().putAll("hash", hash);
      // 新增一个字段
      stringRedisTemplate.opsForHash().put("hash", "field3", "value3");
      // 绑定哈希操作的键，这样可以连续对同一个哈希数据类型进行操作
      var hashOps = stringRedisTemplate.boundHashOps("hash");
      // 删除两个字段
      hashOps.delete("field1", "field2");
      // 新增一个字段
      hashOps.put("field4", "value4");
   }
}
```

##### 操作列表（链表）数据类型
```java
private void testList() {
   // 插入两个列表，注意它们在链表的顺序
   // 链表从右到左顺序为v10,v8,v6,v4,v2
   stringRedisTemplate.opsForList().leftPushAll(
        "list1", "v2", "v4", "v6", "v8", "v10");
   // 链表从左到右顺序为v1,v2,v3,v4,v5,v6
   stringRedisTemplate.opsForList().rightPushAll(
        "list2", "v1", "v2", "v3", "v4", "v5", "v6");
   // 绑定list2链表操作
   var listOps = stringRedisTemplate.boundListOps("list2");
   // 从右边弹出一个成员
   var result1 = listOps.rightPop();
   // 获取定位元素，Redis从0开始计算，这里值为v2
   var result2 = listOps.index(1);
   // 从左边插入链表
   listOps.leftPush("v0");
   // 求链表长度
   var size = listOps.size();
   // 求链表下标区间成员，整个链表下标范围为0~size-1，这里不取最后一个元素
   var elements = listOps.range(0, size-2);
}
```

##### 操作集合数据类型
```java
private void testSet() {
   // 注意，这里v1重复两次，因为集合不允许重复，所以只插入5个成员到集合中
   stringRedisTemplate.opsForSet().add("set1",
         "v1","v1","v2","v3","v4","v5");
   stringRedisTemplate.opsForSet().add("set2", "v2","v4","v6","v8");
   // 绑定set1集合操作
   var setOps = stringRedisTemplate.boundSetOps("set1");
   // 增加两个元素
   setOps.add("v6", "v7");
   // 删除两个元素
   setOps.remove("v1", "v7");
   // 返回所有元素
   var set1 = setOps.members();
   // 求成员数
   Long size = setOps.size();
   // 求交集
   var inter = setOps.intersect("set2");
   // 求交集，并且用新集合inter保存
   setOps.intersectAndStore("set2", "inter");
   // 求差集
   var diff = setOps.difference("set2");
   // 求差集，并且用新集合diff保存
   setOps.differenceAndStore("set2", "diff");
   // 求并集
   var union = setOps.union("set2");
   // 求并集，并且用新集合union保存
   setOps.unionAndStore("set2", "union");
}
```

##### 操作有序集合数据类型
```java
private void testZset() {
   var typedTupleSet = new HashSet<ZSetOperations.TypedTuple<String>>();
   for (int i=1; i<=9; i++) {
      // 分数
      var score = i*0.1;
      // 创建TypedTuple对象，存入值和分数
      var typedTuple = ZSetOperations.TypedTuple.of("value"+i, score);
      typedTupleSet.add(typedTuple);
   }
   // 向有序集合中插入元素
   stringRedisTemplate.opsForZSet().add("zset1", typedTupleSet);
   // 绑定zset1有序集合操作
   var zsetOps = stringRedisTemplate.boundZSetOps("zset1");
   // 增加一个元素
   zsetOps.add("value10", 0.26);
   var setRange = zsetOps.range(1, 6);
   // 按分数排序获取有序集合
   var setScore = zsetOps.rangeByScore(0.2, 0.6);
   // 开始值，exclusive()方法表示不包含该值
   var lower = Range.Bound.exclusive("value3");
   // 结束值，inclusive()方法表示包含该值
   var upper = Range.Bound.inclusive("value8");
   // 定义值范围
   var range = Range.of(lower, upper);
   // 按值排序，注意这个排序是按字符串排序
   var setLex = zsetOps.rangeByLex(range);
   // 删除元素
   zsetOps.remove("value9", "value2");
   // 求分数
   var score = zsetOps.score("value8");
   // 在下标区间下，按分数排序，同时返回value和score
   var rangeSet = zsetOps.rangeWithScores(1, 6);
   // 在分数区间下，按分数排序，同时返回value和score
   var scoreSet = zsetOps.rangeByScoreWithScores(0.2, 0.6);
   // 按从大到小排序
   var reverseSet = zsetOps.reverseRange(2, 8);
}
```

####  使用Redis事务
![[Pasted image 20240827091533.png]]

```java
public void testMulti() {
   redisTemplate.opsForValue().set("key1", "value1");
   var list = (List)redisTemplate.execute(new SessionCallback() {
      @Override
      public Object execute(RedisOperations operations) throws DataAccessException {
         // 设置要监控key1
         operations.watch("key1");
         // 开启事务，在exec命令执行前，将命令存储在队列里
         operations.multi();
         operations.opsForValue().set("key2", "value2");
         // operations.opsForValue().increment("key1", 1);// ①
         // 获取的值为空，因为Redis只是把命令放入队列里
         var value2 = operations.opsForValue().get("key2");
         System.out.println("命令在队列，所以value为null【"+ value2 +"】");
         operations.opsForValue().set("key3", "value3");
         var value3 = operations.opsForValue().get("key3");
         System.out.println("命令在队列，所以value为null【"+ value3 +"】");
         // 执行exec命令，将先判别key1是否在监控后被修改过，如果是则取消事务，否则就执行事务
         return operations.exec();// ②
      }
   });
   System.out.println(list);
}
```
测试
```java
private void testPipeline() {
   var start = System.currentTimeMillis();
   var list = (List)redisTemplate.executePipelined(new SessionCallback() {
      @Override
      public Object execute(RedisOperations operations) throws DataAccessException{
         for (int i=1; i<=100000; i++) {
            operations.opsForValue().set("pipeline_" + i, "value_" + i);
            String value = (String) operations.opsForValue().get("pipeline_" + i);
            if (i % 10000 == 0) {
               System.out.println("命令只是进入队列，所以值为空【" + value +"】");
            }
         }
         return null;
      }
   });
   var end = System.currentTimeMillis();
   System.out.println("耗时：" + (end - start) + "ms。");
}
```


#### 使用Redis发布/订阅
![[Pasted image 20240827091826.png|475]]

Redis消息监听器




