### Stream介绍及其基本操作
```java
final List<String> result = books.stream() // 书的类目为Programming .filter(book->book.category.equals("Programming")) // 根据价格排序 .sorted(Comparator.comparing(Book::getPrice)) // 只获取书的名字 .map(Book::getName) // 然后将所有符合条件的结果保存在一个新的List中 .collect(Collectors.toList());

final List<String> result = books.parallelStream() .filter(book->book.category.equals("Programming")) .sorted(Comparator.comparing(Book::getPrice)) .map(Book::getName) .collect(Collectors.toList());
```
通过parallelStream()方法创建一个并行流，开发者既无须关心有多少个线程在工作，线程如何管理，也无须担心列表在并行流下的线程安全性问题。

#### 如何创建Stream
Java的Stream具有如下几个特点。
▪ Stream不存储数据，这是其与Collection最大的区别之一。
▪ Stream不是数据结构，而是从Collection、数组、I/O等获取输入。
▪ Stream不会改变原来的数据结构。
▪ Stream可以是无限元素集合。
▪ Stream支持lazy操作。
▪ 每一个intermediate操作都将会以lazy的方式执行，并且返回一个新的Stream，比如filter()方法。
▪ Terminal操作将会结束Stream，并且返回最终结果，比如collect()方法。
▪ Stream无法被重用，即对Stream的每一次操作都会产生一个全新的Stream。
▪ Stream支持函数式编程。

大概了解了Stream之后，我们一起看一下可以通过哪些方式获取或者创建Stream。
（1）From Values：利用Stream接口提供的静态方法of获取一个Stream
```java
private static Stream<Integer> fromValues()
{
    return Stream.of(1, 2, 3, 4);
}
public static void main(String[] args)
{
    Stream<Integer> stream = fromValues().map(i ->
    {
        System.out.println("multiply by 2");
        return i * 2;
    });
    System.out.println("================");
    stream.forEach(System.out::println);
}
```

（2）通过Stream.Builder来创建Stream
```java
private static Stream<Integer> fromBuilder()
{
    return Stream.<Integer>builder()
                 .add(1)
                 .add(2)
                 .add(3)
                 .add(4)
                 .build();
}
```
借助于Stream的Builder也可以创建一个Stream，该Builder同时又继承自函数式接口`Consumer<T>`。

（3）空Streams
假设我们所写的方法其返回类型是`Stream<T>`类型，有些时候可能需要返回一个空的Stream，就像返回空的字符串、空的集合容器等一样，这里创建一个空的`Stream<T>`类型，并且将其作为返回值。
```java
private static Stream<File> emptyStream(){
    return Stream.empty();
}
```

如果是基本数据类型，则可以使用相关的NumericStream直接返回。
```java
IntStream intStream = IntStream.empty();
LongStream longStream = LongStream.empty();
DoubleStream doubleStream = DoubleStream.empty();
```

（4）通过Functions创建无限元素的Stream
`Stream<T>`接口还提供了创建无限元素的Stream方法：generate和iterate方法。
▪ generate方法需要一个Supplier函数式接口。

▪ iterate方法需要一个seed和UnaryOperator函数式接口。
```java
private static Stream<Integer> infiniteStreamByIterate()
{
    return Stream.iterate(100, seed -> seed + 1);
}
```

（5）通过NumericStream创建无限元素的Stream
通过相关的NumericStream iterate和generate方法创建Stream。
```java
LongStream iterate(final long seed, final LongUnaryOperator f)
LongStream generate(LongSupplier s)
DoubleStream generate(DoubleSupplier s)
DoubleStream iterate(final double seed, final DoubleUnaryOperator f)
IntStream iterate(final int seed, final IntUnaryOperator f)
IntStream generate(IntSupplier s)
```

（6）通过NumericStream创建有限元素的Stream
NumericStream除了提供创建无限元素的方法之外，还提供了创建有限元素的静态方法，下面以IntStream为例进行说明。
```java
private static IntStream rangeNumericStream()
{
    // IntStream的range方法将会创建一个半开半闭的区间{x|1<=x<10}
    return IntStream.range(1, 10);
}

private static IntStream rangeClosedNumericStream(){
    // IntStream的range方法将会创建一个闭区间{x|1<=x<=10}
    return IntStream.rangeClosed(1,10);
}
```

（7）通过数组创建Stream
自JDK 1.8以来，java.util.Arrays提供了stream()静态方法，通过该方法，我们可以创建Stream。
```java
private static Stream<Entity> fromArrays()
{
    return Arrays.stream(new Entity[]{new Entity(), new Entity()});
}
```

（8）通过集合容器创建Stream
自JDK 1.8版本开始，Collection接口增加了新的方法stream()用于创建与之关联的Stream对象。
```java
private static Stream<String> fromCollection()
 {
    Collection<String> list = Arrays.asList("Hello", "Stream");
    return list.stream();
 }
```

（9）通过Map容器创建Stream
Map并未提供创建Stream的方法，但是我们可以通过entry set的方式间接创建一个类型为Entry键值对的元素序列，提供对Map的Stream支持。
```java
private static Stream<Map.Entry<String, String>> fromMap()
{
    return new HashMap<String, String>()
    {
        {
            put("Hello", "Stream");
            put("Java", "Programming");
        }
    }
    .entrySet() // 获取Entry<String,String>的Set
    .stream();  // 进而创建一个Stream<Map.Entry<String,String>>
}
```

（10）通过Files创建Stream
java.io和java.nio.file包支持通过Streams对I/O进行操作。比如，你可以读取一个文本文件，并且创建String类型的Stream，该Stream元素序列中的每一个元素就代表了该文件的每一行文本。
```java
private static Stream<String> fromFile() throws IOException
{
    return Files.lines(Paths.get("test.txt"),
                       Charset.forName("UTF-8"));
}
```

（11）通过其他方式创建Stream
除了本节所列举的一些创建Stream的方式，还有很多其他的方式，比如，可以通过String创建IntStream。甚至一些第三方框架或者平台都提供了对Stream操作的支持，比如Spark、Flink、Storm的Trident、JOOQ等，除此之外，本章的最后将为大家展示如何自定义一个Stream，以便大家更加深入地理解Stream。
```java
private static IntStream fromString()
{
    String line = "Hello i am Stream";
    return line.chars();
}
```

#### Stream之Intermediate操作
Stream主要分为两种类型，Intermediate和Terminal。filter、sorted、map之类的操作被称为Intermediate操作，这类操作的结果都是一个全新的Stream类型。多个Intermediate操作构成了一个流水线（pipeline）​，除此之外，Intermediate操作的执行都是通过lazy的方式，直到遇到最后的Terminal操作
```java
// 这里通过Stream的of方法创建了一个Stream，我们将其称为sourceStream
Stream<Integer> sourceStream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
// 在sourceStream上执行了map操作（该操作为Intermediate操作），并且返回一个新的stream mapStream
Stream<Integer> mapStream = sourceStream.map(i -> i * 2);
// 再次对source stream执行foreach操作（该操作为Terminal操作）
sourceStream.forEach(System.out::println);
```
![[Pasted image 20240924144149.png]]

#### Stream之Terminal操作

