### Stream介绍及其基本操作
```java
final List<String> result = books.stream() // 书的类目为Programming .filter(book->book.category.equals("Programming")) // 根据价格排序 .sorted(Comparator.comparing(Book::getPrice)) // 只获取书的名字 .map(Book::getName) // 然后将所有符合条件的结果保存在一个新的List中 .collect(Collectors.toList());

final List<String> result = books.parallelStream() .filter(book->book.category.equals("Programming")) .sorted(Comparator.comparing(Book::getPrice)) .map(Book::getName) .collect(Collectors.toList());
```
通过parallelStream()方法创建一个并行流，开发者既无须关心有多少个线程在工作，线程如何管理，也无须担心列表在并行流下的线程安全性问题。

#### 如何创建Stream
Java的Stream具有如下几个特点。
▪ Stream不存储数据，这是其与Collection最大的区别之一。
▪ Stream不是数据结构，而是从Collection、数组、I/O等获取输入。
▪ Stream不会改变原来的数据结构。
▪ Stream可以是无限元素集合。
▪ Stream支持lazy操作。
▪ 每一个intermediate操作都将会以lazy的方式执行，并且返回一个新的Stream，比如filter()方法。
▪ Terminal操作将会结束Stream，并且返回最终结果，比如collect()方法。
▪ Stream无法被重用，即对Stream的每一次操作都会产生一个全新的Stream。
▪ Stream支持函数式编程。

大概了解了Stream之后，我们一起看一下可以通过哪些方式获取或者创建Stream。
（1）From Values：利用Stream接口提供的静态方法of获取一个Stream
```java
private static Stream<Integer> fromValues()
{
    return Stream.of(1, 2, 3, 4);
}
public static void main(String[] args)
{
    Stream<Integer> stream = fromValues().map(i ->
    {
        System.out.println("multiply by 2");
        return i * 2;
    });
    System.out.println("================");
    stream.forEach(System.out::println);
}
```

（2）通过Stream.Builder来创建Stream
```java
private static Stream<Integer> fromBuilder()
{
    return Stream.<Integer>builder()
                 .add(1)
                 .add(2)
                 .add(3)
                 .add(4)
                 .build();
}
```
借助于Stream的Builder也可以创建一个Stream，该Builder同时又继承自函数式接口`Consumer<T>`。

（3）空Streams
假设我们所写的方法其返回类型是`Stream<T>`类型，有些时候可能需要返回一个空的Stream，就像返回空的字符串、空的集合容器等一样，这里创建一个空的`Stream<T>`类型，并且将其作为返回值。
```java
private static Stream<File> emptyStream(){
    return Stream.empty();
}
```

如果是基本数据类型，则可以使用相关的NumericStream直接返回。
```java
IntStream intStream = IntStream.empty();
LongStream longStream = LongStream.empty();
DoubleStream doubleStream = DoubleStream.empty();
```

（4）通过Functions创建无限元素的Stream
`Stream<T>`接口还提供了创建无限元素的Stream方法：generate和iterate方法。
▪ generate方法需要一个Supplier函数式接口。

▪ iterate方法需要一个seed和UnaryOperator函数式接口。
```java
private static Stream<Integer> infiniteStreamByIterate()
{
    return Stream.iterate(100, seed -> seed + 1);
}
```

（5）通过NumericStream创建无限元素的Stream
通过相关的NumericStream iterate和generate方法创建Stream。
```java
LongStream iterate(final long seed, final LongUnaryOperator f)
LongStream generate(LongSupplier s)
DoubleStream generate(DoubleSupplier s)
DoubleStream iterate(final double seed, final DoubleUnaryOperator f)
IntStream iterate(final int seed, final IntUnaryOperator f)
IntStream generate(IntSupplier s)
```

（6）通过NumericStream创建有限元素的Stream
NumericStream除了提供创建无限元素的方法之外，还提供了创建有限元素的静态方法，下面以IntStream为例进行说明。
```java
private static IntStream rangeNumericStream()
{
    // IntStream的range方法将会创建一个半开半闭的区间{x|1<=x<10}
    return IntStream.range(1, 10);
}

private static IntStream rangeClosedNumericStream(){
    // IntStream的range方法将会创建一个闭区间{x|1<=x<=10}
    return IntStream.rangeClosed(1,10);
}
```

（7）通过数组创建Stream
自JDK 1.8以来，java.util.Arrays提供了stream()静态方法，通过该方法，我们可以创建Stream。
```java
private static Stream<Entity> fromArrays()
{
    return Arrays.stream(new Entity[]{new Entity(), new Entity()});
}
```

（8）通过集合容器创建Stream
自JDK 1.8版本开始，Collection接口增加了新的方法stream()用于创建与之关联的Stream对象。
```java
private static Stream<String> fromCollection()
 {
    Collection<String> list = Arrays.asList("Hello", "Stream");
    return list.stream();
 }
```

（9）通过Map容器创建Stream
Map并未提供创建Stream的方法，但是我们可以通过entry set的方式间接创建一个类型为Entry键值对的元素序列，提供对Map的Stream支持。
```java
private static Stream<Map.Entry<String, String>> fromMap()
{
    return new HashMap<String, String>()
    {
        {
            put("Hello", "Stream");
            put("Java", "Programming");
        }
    }
    .entrySet() // 获取Entry<String,String>的Set
    .stream();  // 进而创建一个Stream<Map.Entry<String,String>>
}
```

（10）通过Files创建Stream
java.io和java.nio.file包支持通过Streams对I/O进行操作。比如，你可以读取一个文本文件，并且创建String类型的Stream，该Stream元素序列中的每一个元素就代表了该文件的每一行文本。
```java
private static Stream<String> fromFile() throws IOException
{
    return Files.lines(Paths.get("test.txt"),
                       Charset.forName("UTF-8"));
}
```

（11）通过其他方式创建Stream
除了本节所列举的一些创建Stream的方式，还有很多其他的方式，比如，可以通过String创建IntStream。甚至一些第三方框架或者平台都提供了对Stream操作的支持，比如Spark、Flink、Storm的Trident、JOOQ等，除此之外，本章的最后将为大家展示如何自定义一个Stream，以便大家更加深入地理解Stream。
```java
private static IntStream fromString()
{
    String line = "Hello i am Stream";
    return line.chars();
}
```

#### Stream之Intermediate操作
Stream主要分为两种类型，Intermediate和Terminal。filter、sorted、map之类的操作被称为Intermediate操作，这类操作的结果都是一个全新的Stream类型。多个Intermediate操作构成了一个流水线（pipeline）​，除此之外，Intermediate操作的执行都是通过lazy的方式，直到遇到最后的Terminal操作
```java
// 这里通过Stream的of方法创建了一个Stream，我们将其称为sourceStream
Stream<Integer> sourceStream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
// 在sourceStream上执行了map操作（该操作为Intermediate操作），并且返回一个新的stream mapStream
Stream<Integer> mapStream = sourceStream.map(i -> i * 2);
// 再次对source stream执行foreach操作（该操作为Terminal操作）
sourceStream.forEach(System.out::println);
```
![[Pasted image 20240924144149.png]]

#### Stream之Terminal操作
Stream的Terminal操作会终结Stream的流水线（pipeline）的继续执行，最终返回一个非Stream类型的结果（foreach操作可以理解为返回的是void类型的结果）​。因此在一个Stream的流水线中执行了Terminal方法之后，Stream将被关闭。
![[Pasted image 20240924144320.png]]

#### NumericStream详解
▪ IntStream：元素为int类型的Stream。
▪ DoubleStream：元素为double类型的Stream。
▪ LongStream：元素为long类型的Stream。

1. 为何要有NumericStream
首先NumericStream提供了更多针对数据类型的操作方式，比如可以通过sum这个Terminal操作直接获取IntStream中所有int元素相加的和，可以通过max操作直接获取在IntStream中最大的int类型的元素而无须传入Comparator，还可以通过min操作直接获取在IntStream中最小的int类型的元素而无须传入Comparator。
```java
// 直接使用sum操作返回Stream中所有元素之和
assert IntStream.of(1, 2, 3, 4, 5).sum() == 15;
// 直接使用max操作返回最大值OptionalInt
assert IntStream.of(1, 2, 3, 4, 5).max().getAsInt() == 5;
// 直接使用min操作返回最小值OptionalInt
assert IntStream.of(1, 2, 3, 4, 5).min().getAsInt() == 1;
```
```java
package com.wangwenjun.concurrent.streams;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;
import java.util.stream.Stream;

@Warmup(iterations = 20)
@Measurement(iterations = 20)
@Fork(1)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Thread)
public class StreamIntegerVsIntStream
{
    // 定义Stream<Integer>
    private Stream<Integer> integerStream;
    // 定义IntStream
    private IntStream intStream;

    // 注意Level必须是Invocation，原因是Stream只能操作一次，前文中已经解释过
    @Setup(Level.Invocation)
    public void init()
    {
        this.integerStream = IntStream.range(0, 100).boxed();
        this.intStream = IntStream.range(0, 100);
    }
    // Stream<Integer>所有的操作都需要经历拆箱和封箱的过程
    @Benchmark
    public void streamIntegerReduce(Blackhole hole)
    {
        int result = this.integerStream
                         .map((Integer i) -> i * 10)
                         .reduce(0, (Integer a, Integer b) ->
                         {
                            return a + b;
                         });
        hole.consume(result);
    }

    // Stream<Integer>在进行操作之前先主动拆箱，然后再进行其他的操作
    @Benchmark
    public void streamIntegerUnboxThenReduce(Blackhole hole)
    {
        int result = integerStream
                .mapToInt(Integer::intValue)
                .map((int i) -> i * 10)
                .reduce(0, (int a, int b) ->
                {
                    return a + b;
                });
        hole.consume(result);
    }

    // 所有的操作都是基于基本类型int的
    @Benchmark
    public void intStreamReduce(Blackhole hole)
    {
        int result = intStream
                .map((int i) -> i * 10)
                .reduce(0, (int a, int b) ->
                {
                    return a + b;
                });
        hole.consume(result);
    }

    public static void main(String[] args) throws RunnerException
    {
        final Options opt = new OptionsBuilder()
           .include(StreamIntegerVsIntStream.class.getSimpleName())
           .build();
        new Runner(opt).run();
    }
}


Benchmark                     Mode  Cnt  Score   Error  Units
intStreamReduce               avgt   20  1.914 ± 0.449  us/op
streamIntegerReduce           avgt   20  2.921 ± 0.462  us/op
streamIntegerUnboxThenReduce  avgt   20  2.474 ± 0.120  us/op
```

2. Stream之间的互转
在基准测试StreamIntegerVsIntStream.java的streamIntegerUnboxThenReduce方法中，已经提到如何将一个`Stream<Integer>`转换为IntStream的操作，IntStream想要转换为`Stream<Integer>`，采用的也是类似的操作，本节就来简单总结一下。
（1）Stream转换为NumericStream
▪ `IntStream mapToInt(ToIntFunction<? super T> mapper)`：转换为IntStream。
▪ `LongStream mapToLong(ToLongFunction<? super T> mapper)`：转换为LongStream。
▪ `DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper)`：转换为DoubleStream。

（2）IntStream转换为其他Stream
▪ `Stream<Integer> boxed()`：转换为`Stream<Integer>`。
▪ `Stream<U> mapToObj(IntFunction<? extends U> mapper)`：转换为`Stream<U>`。
▪ LongStream mapToLong(IntToLongFunction mapper)：转换为LongStream。
▪ DoubleStream mapToDouble(IntToDoubleFunction mapper)：转换为DoubleStream。
▪ LongStream asLongStream()：转换为LongStream。▪ DoubleStream asDoubleStream()：转换为DoubleStream。

（3）LongStream转换为其他Stream
▪ Stream<Long> boxed()：转换为`Stream<Long>`。
▪ DoubleStream asDoubleStream()：转换为DoubleStream。
▪ Stream<U> mapToObj(LongFunction<? extends U> mapper)：转换为Stream<U>。
▪ IntStream mapToInt(LongToIntFunction mapper)：转换为IntStream。
▪ DoubleStream mapToDouble(LongToDoubleFunction mapper)：转换为DoubleStream。（4）DoubleStream转换为其他Stream▪ Stream<Double> boxed()：转换为Stream<Double>。
▪ Stream<U> mapToObj(DoubleFunction<? extends U> mapper)：转换为Stream<U>。
▪ IntStream mapToInt(DoubleToIntFunction mapper)：转换为IntStream。
▪ LongStream mapToLong(DoubleToLongFunction mapper)：转换为LongStream。（5）串行流与并行流之间的转换默认情况下，我们创建的Stream都是sequential（串行的）​，但是如果想将其转换为并行流，则可以借助于parallel()方法将一个串行流转换为并行流，在并行流的运算中，操作将被并行化地运行。

