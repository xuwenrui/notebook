### 链表


#### 基本的链表
所谓链表，实际上就是线性表的链式存储方式，有别于数组连续式内存空间，链表并不是连续的内存存储结构。在链表的每一个节点中，至少包含着两个基本属性：数据本身和指向下一个节点的引用或者指针
![[Pasted image 20240923140243.png|500]]
根据链表节点元素的不同访问形式就可以演化出栈，即最先进入链表结构的元素最后一个被访问（FILO：first in last out或者LIFO：last in first out）​；还可以演化出队列，即最先进入链表结构的元素第一个被访问（FIFO：first in first out或者LILO：Last in Last out）​；此外在链表元素节点中多增加一个指针属性就可以演化出二叉树等，所以说链表数据结构是最基本、最常用的数据结构一点都不为过。图4-1中所描绘的链表仅是单向链表，链表还包含双向链表、循环链表等。
```java
// Node是一个泛型类，可用于存储任意类型元素的节点
class Node<T>
{
    // 数据属性
    private final T value;
    // 指向下一个节点的引用
    private final Node<T> next;
    private Node(T value, Node<T> next)
    {
        this.value = value;
        this.next = next;
    }
    public T getValue()
    {
        return value;
    }
    public Node<T> getNext()
    {
        return next;
    }
}
```

##### （1）链表的构造
链表中有一个非常重要的元素Head，它代表当前节点元素的引用，当链表被初始化时，当前节点属性指向为NULL
```java
// 当前节点引用
private Node<E> header;
// 链表元素的个数
private int size;

public MyList()
{
    // 当前元素节点为指向NULL的属性
    this.header = null;
}
```

##### （2）链表数据的清空以及是否为空的判断
```java
// 判断当前列表是否为空
public boolean isEmpty()
{
    // 只需要判断当前节点引用是否为null即可得知
    return header == null;
}

// 清除链表中的所有元素
public void clear()
{
    // 显式设定当前size为0
    this.size = 0;
    // 将当前节点引用设置为null即可，由于其他元素ROOT不可达，因此在稍后的垃圾回收中将会被回收
    this.header = null;
}
```

##### （3）向链表头部增加元素
```java
public void add(E e)
{
    // 定义新的node节点，并且其next引用指向当前节点所引用的header
    Node node = new Node<>(e, header);
    // 将当前节点header指向新的node节点
    this.header = node;
    // 元素数量加一
    this.size++;
}
```

##### （4）链表的peekFirst操作
```java
public E peekFirst()
{
   // 如果为空则直接抛出异常
    if (isEmpty())
    {
        throw new IndexOutOfBoundsException("The linked list is empty now, can't support peek operation");
    }
    // 返回当前节点的元素数据
    return header.getValue();
}
```

##### （5）链表元素的弹出操作
```java
public E popFirst()
{
    // 判断当前链表是否为空
    if (isEmpty())
    {
    // 如果为空则直接抛出异常
        throw new IndexOutOfBoundsException("The linked list is empty now, can't support pop operation");
    }
    // 获取当前节点的数据，作为该方法的最终返回值
    final E value = header.getValue();
    // 将链表的当前节点引用直接指向当前节点的下一个节点
    this.header = header.getNext();
    // 元素数量减一
    this.size--;
    // 返回数据
    return value;
}
```

#### 优先级链表
```java
// 增加泛型约束，每一个被加入该链表中的元素都必须实现Comparable接口，就像基本数据类型String一样
public class MyPriorityList<E extends Comparable<E>>
{
   /**
    * Node节点的泛型类型同样增加了相关的约束，并且取缔了value和next字段不
    *可变的特性
    */
    private static class Node<T extends Comparable<T>>
    {
        private T value;
        private Node<T> next;

        private Node(T value, Node<T> next)
        {
            this.value = value;
            this.next = next;
        }

        private Node(T value)
        {
            this(value, null);
        }

        public T getValue()
        {
            return value;
        }

        public Node<T> getNext()
        {
            return next;
        }

       // 新增了set方法
        public void setValue(T value)
        {
            this.value = value;
        }

       // 新增了对next引用的set方法
        public void setNext(Node<T> next)
        {
            this.next = next;
        }
    }

    private Node<E> header;

    private int size;
    // 增加了Comparator接口属性
    private final Comparator<E> comparator;
    // 在构造函数中强制要求必须要有Comparator接口
    public MyPriorityList(Comparator<E> comparator)
    {
        this.comparator = Objects.requireNonNull(comparator);
        this.header = null;
    }
```

#### 跳表（SkipList）
```java
package com.wangwenjun.concurrent.juc.collection;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Random;
import java.util.concurrent.TimeUnit;

@Warmup(iterations = 20)
@Measurement(iterations = 20)
@Fork(1)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Thread)
public class BinarySearch
{
    private ArrayList<Integer> arrayList;
    private LinkedList<Integer> linkedList;
    private Random random;

    // 设置基准测试套件方法，Level为Trial
    @Setup(Level.Trial)
    public void setUp()
    {
        // 初始化随机值
        this.random = new Random(System.currentTimeMillis());
        // 初始化arrayList和linkedList并且存入一千万个已经排序的元素
        this.arrayList = new ArrayList<>();
        this.linkedList = new LinkedList<>();
        for (int i = 0; i < 10_000_000; i++)
        {
            arrayList.add(i);
            linkedList.add(i);
        }
    }

    @Benchmark
    public void binarySearchFromArrayList(Blackhole blackhole)
    {
        int randomValue = random.nextInt(10_000_000);
        int result = Collections
              .binarySearch(arrayList, randomValue);
        blackhole.consume(result);
    }

    @Benchmark
    public void binarySearchFromLinkedList(Blackhole blackhole)
    {
        int randomValue = random.nextInt(10_000_000);
        int result = Collections
                  .binarySearch(linkedList, randomValue);
        blackhole.consume(result);
    }

    public static void main(String[] args) throws RunnerException
    {
        final Options opt = new OptionsBuilder()
                .include(BinarySearch.class.getSimpleName())
                .build();
        new Runner(opt).run();
    }
}
```
https://weread.qq.com/web/reader/30b3225071eeefb430bb397kd67323c0227d67d8ab4fb04

### BlockingQueue（阻塞队列）

#### ArrayBlockingQueue
ArrayBlockingQueue是一个基于数组结构实现的FIFO阻塞队列，在构造该阻塞队列时需要指定队列中最大元素的数量（容量）​。当队列已满时，若再次进行数据写入操作，则线程将会进入阻塞，一直等待直到其他线程对元素进行消费。当队列为空时，对该队列的消费线程将会进入阻塞，直到有其他线程写入数据。
###### 1. 阻塞式写方法
在ArrayBlockingQueue中提供了两个阻塞式写方法，分别如下（在该队列中，无论是阻塞式写方法还是非阻塞式写方法，都不允许写入null）​。
▪ void put(E e)：向队列的尾部插入新的数据，当队列已满时调用该方法的线程会进入阻塞，直到有其他线程对该线程执行了中断操作，或者队列中的元素被其他线程消费。
```java
// 构造只有两个元素容量的ArrayBlockingQueue
ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(2);
try
{
    queue.put("first");
    queue.put("second");
    // 执行put将会使得当前线程进入阻塞
    queue.put("third");
} catch (InterruptedException e)
{
    e.printStackTrace();
}
```
▪ boolean offer(E e, long timeout, TimeUnit unit)：向队列尾部写入新的数据，当队列已满时执行该方法的线程在指定的时间单位内将进入阻塞，直到到了指定的超时时间后，或者在此期间有其他线程对队列数据进行了消费。当然了，对由于执行该方法而进入阻塞的线程执行中断操作也可以使当前线程退出阻塞。该方法的返回值boolean为true时表示写入数据成功，为false时表示写入数据失败。
```java
ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(2);
try
{
    queue.offer("first", 10, TimeUnit.SECONDS);
    queue.offer("second", 10, TimeUnit.SECONDS);
    // 该方法会进入阻塞，10秒之后当前线程将会退出阻塞，并且对third数据的写入将会失败
    queue.offer("third", 10, TimeUnit.SECONDS);
} catch (InterruptedException e)
{
    e.printStackTrace();
}
```

###### 2. 非阻塞式写方法
当队列已满时写入数据，如果不想使得当前线程进入阻塞，那么就可以使用非阻塞式的写操作方法。
▪ boolean add(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，但是该方法会抛出队列已满的异常。
▪ boolean offer(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，并且会立即返回false。

###### 3. 阻塞式读方法
ArrayBlockingQueue中提供了两个阻塞式读方法，分别如下。
▪ E take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，直到有其他线程写入新的数据，或者当前线程被执行了中断操作。
▪ E poll(long timeout, TimeUnit unit)：从队列头部获取数据并且该数据会从队列头部移除，如果队列中没有任何元素时则执行该方法，当前线程会阻塞指定的时间，直到在此期间有新的数据写入，或者阻塞的当前线程被其他线程中断，当线程由于超时退出阻塞时，返回值为null。
###### 4. 非阻塞式读方法
当队列为空时读取数据，如果不想使得当前线程进入阻塞，那么就可以使用非阻塞式的读操作方法。
▪ E poll()：从队列头部获取数据并且该数据会从队列头部移除，当队列为空时，该方法不会使得当前线程进入阻塞，而是返回null值。
▪ E peek()：peek的操作类似于debug操作（仅仅debug队列头部元素，本书的第6章将讲解针对Stream的操作，大家将从中学习到针对整个Stream数据元素的peek操作）​，它直接从队列头部获取一个数据，但是并不能从队列头部移除数据，当队列为空时，该方法不会使得当前线程进入阻塞，而是返回null值。
###### 5. 生产者消费者
```java
// 定义阻塞队列
ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(10);
// 启动11个生产数据的线程，向队列的尾部写入数据
IntStream.rangeClosed(0, 10)
.boxed()
.map(i -> new Thread("P-Thread-" + i)
{
    @Override
    public void run()
    {
        while (true)
        {
            try
            {
                String data = String.valueOf(System.currentTimeMillis());
                queue.put(data);
                System.out.println(currentThread() + " produce data: " + data);
                TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5));
            } catch (InterruptedException e)
            {
                System.out.println("Received the interrupt SIGNAL.");
                break;
            }
        }
    }
}).forEach(Thread::start);

// 定义11个消费线程，从队列的头部移除数据
IntStream.rangeClosed(0, 10)
.boxed()
.map(i -> new Thread("C-Thread-" + i)
{
    @Override
    public void run()
    {
        while (true)
        {
            try
            {
                String data = queue.take();
                System.out.println(currentThread() + " consume data: " + data);
                TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5));
            } catch (InterruptedException e)
            {
                System.out.println("Received the interrupt SIGNAL.");
                break;
            }
        }
    }
}).forEach(Thread::start);
```

##### PriorityBlockingQueue
PriorityBlockingQueue优先级阻塞队列是一个“无边界”阻塞队列.
该队列会根据某种规则（Comparator）对插入队列尾部的元素进行排序，因此该队列将不会遵循FIFO（first-in-first-out）的约束。
###### 1. 排序且无边界的队列
只要应用程序的内存足够使用，理论上，PriorityBlockingQueue存放数据的数量是“无边界”的，在PriorityBlockingQueue内部维护了一个Object的数组，随着数据量的不断增多，该数组也会进行动态地扩容。在构造PriorityBlockingQueue时虽然提供了一个整数类型的参数，但是该参数所代表的含义与ArrayBlockingQueue完全不同，前者是构造PriorityBlockingQueue的初始容量，后者指定的整数类型参数则是ArrayBlockingQueue的最大容量。

###### 2. 不存在阻塞写方法
由于PriorityBlockingQueue是“无边界”的队列，因此将不存在对队列上限临界值的控制，在PriorityBlockingQueue中，添加数据元素的所有方法都等价于offer方法，从队列的尾部添加数据，但是该数据会根据排序规则对数据进行排序。

#### LinkedBlockingQueue
ArrayBlockingQueue是基于数组实现的FIFO“有边界”队列，PriorityBlockingQueue也是基于数组实现的，但它是“无边界”的优先级队列，由于存在对数据元素的排序规则，因此PriorityBlockingQueue并不能提供FIFO的约束担保（当然，如果想要使其具备FIFO的特性，需要约束PriorityBlockingQueue的排序规则为R，并且对其写入数据的顺序也为R，这样就可以保证FIFO）​，本节将要介绍的LinkedBlockingQueue是“可选边界”基于链表实现的FIFO队列。截至目前，本章所学习到阻塞队列都是通过显式锁Lock进行共享数据的同步，以及与Lock关联的Condition进行线程间通知，因此该队列也适用于高并发的多线程环境中，是线程安全的类。


#### DelayQueue
DelayQueue也是一个实现了BlockingQueue接口的“无边界”阻塞队列，但是该队列却是非常有意思和特殊的一个队列（存入DelayQueue中的数据元素会被延迟单位时间后才能消费）​，在DelayQueue中，元素也会根据优先级进行排序，这种排序可以是基于数据元素过期时间而进行的（比如，你可以将最快过期的数据元素排到队列头部，最晚过期的数据元素排到队尾）​。

#### SynchronousQueue
SynchronousQueue也是实现自BlockingQueue的一个阻塞队列，每一次对其的写入操作必须等待（阻塞）其他线程进行对应的移除操作，SynchronousQueue的内部并不会涉及容量、获取size，就连peek方法的返回值永远都将会是null，除此之外还有更多的方法在SynchronousQueue中也都未提供对应的支持（列举如下）​，因此在使用的过程中需要引起注意，否则会使得程序的运行出现不符合预期的错误。

#### LinkedBlockingDeque
LinkedBlockingDeque是一个基于链表实现的双向（Double Ended Queue，Deque）阻塞队列，双向队列支持在队尾写入数据，读取移除数据；在队头写入数据，读取移除数据。LinkedBlockingDeque实现自BlockingDeque（BlockingDeque又是BlockingQueue的子接口）​，并且支持可选“边界”​，与LinkedBlockingQueue一样，对边界的指定在构造LinkedBlockingDeque时就已经确定了。
![[Pasted image 20240923143400.png]]



