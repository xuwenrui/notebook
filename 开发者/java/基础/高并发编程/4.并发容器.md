### 链表


#### 基本的链表
所谓链表，实际上就是线性表的链式存储方式，有别于数组连续式内存空间，链表并不是连续的内存存储结构。在链表的每一个节点中，至少包含着两个基本属性：数据本身和指向下一个节点的引用或者指针
![[Pasted image 20240923140243.png|500]]
根据链表节点元素的不同访问形式就可以演化出栈，即最先进入链表结构的元素最后一个被访问（FILO：first in last out或者LIFO：last in first out）​；还可以演化出队列，即最先进入链表结构的元素第一个被访问（FIFO：first in first out或者LILO：Last in Last out）​；此外在链表元素节点中多增加一个指针属性就可以演化出二叉树等，所以说链表数据结构是最基本、最常用的数据结构一点都不为过。图4-1中所描绘的链表仅是单向链表，链表还包含双向链表、循环链表等。
```java
// Node是一个泛型类，可用于存储任意类型元素的节点
class Node<T>
{
    // 数据属性
    private final T value;
    // 指向下一个节点的引用
    private final Node<T> next;
    private Node(T value, Node<T> next)
    {
        this.value = value;
        this.next = next;
    }
    public T getValue()
    {
        return value;
    }
    public Node<T> getNext()
    {
        return next;
    }
}
```

##### （1）链表的构造
链表中有一个非常重要的元素Head，它代表当前节点元素的引用，当链表被初始化时，当前节点属性指向为NULL
```java
// 当前节点引用
private Node<E> header;
// 链表元素的个数
private int size;

public MyList()
{
    // 当前元素节点为指向NULL的属性
    this.header = null;
}
```

##### （2）链表数据的清空以及是否为空的判断
```java
// 判断当前列表是否为空
public boolean isEmpty()
{
    // 只需要判断当前节点引用是否为null即可得知
    return header == null;
}

// 清除链表中的所有元素
public void clear()
{
    // 显式设定当前size为0
    this.size = 0;
    // 将当前节点引用设置为null即可，由于其他元素ROOT不可达，因此在稍后的垃圾回收中将会被回收
    this.header = null;
}
```

##### （3）向链表头部增加元素
```java
public void add(E e)
{
    // 定义新的node节点，并且其next引用指向当前节点所引用的header
    Node node = new Node<>(e, header);
    // 将当前节点header指向新的node节点
    this.header = node;
    // 元素数量加一
    this.size++;
}
```

##### （4）链表的peekFirst操作
```java
public E peekFirst()
{
   // 如果为空则直接抛出异常
    if (isEmpty())
    {
        throw new IndexOutOfBoundsException("The linked list is empty now, can't support peek operation");
    }
    // 返回当前节点的元素数据
    return header.getValue();
}
```

##### （5）链表元素的弹出操作
```java
public E popFirst()
{
    // 判断当前链表是否为空
    if (isEmpty())
    {
    // 如果为空则直接抛出异常
        throw new IndexOutOfBoundsException("The linked list is empty now, can't support pop operation");
    }
    // 获取当前节点的数据，作为该方法的最终返回值
    final E value = header.getValue();
    // 将链表的当前节点引用直接指向当前节点的下一个节点
    this.header = header.getNext();
    // 元素数量减一
    this.size--;
    // 返回数据
    return value;
}
```

#### 优先级链表
```java
// 增加泛型约束，每一个被加入该链表中的元素都必须实现Comparable接口，就像基本数据类型String一样
public class MyPriorityList<E extends Comparable<E>>
{
   /**
    * Node节点的泛型类型同样增加了相关的约束，并且取缔了value和next字段不
    *可变的特性
    */
    private static class Node<T extends Comparable<T>>
    {
        private T value;
        private Node<T> next;

        private Node(T value, Node<T> next)
        {
            this.value = value;
            this.next = next;
        }

        private Node(T value)
        {
            this(value, null);
        }

        public T getValue()
        {
            return value;
        }

        public Node<T> getNext()
        {
            return next;
        }

       // 新增了set方法
        public void setValue(T value)
        {
            this.value = value;
        }

       // 新增了对next引用的set方法
        public void setNext(Node<T> next)
        {
            this.next = next;
        }
    }

    private Node<E> header;

    private int size;
    // 增加了Comparator接口属性
    private final Comparator<E> comparator;
    // 在构造函数中强制要求必须要有Comparator接口
    public MyPriorityList(Comparator<E> comparator)
    {
        this.comparator = Objects.requireNonNull(comparator);
        this.header = null;
    }
```

#### 跳表（SkipList）
```java
package com.wangwenjun.concurrent.juc.collection;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Random;
import java.util.concurrent.TimeUnit;

@Warmup(iterations = 20)
@Measurement(iterations = 20)
@Fork(1)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Thread)
public class BinarySearch
{
    private ArrayList<Integer> arrayList;
    private LinkedList<Integer> linkedList;
    private Random random;

    // 设置基准测试套件方法，Level为Trial
    @Setup(Level.Trial)
    public void setUp()
    {
        // 初始化随机值
        this.random = new Random(System.currentTimeMillis());
        // 初始化arrayList和linkedList并且存入一千万个已经排序的元素
        this.arrayList = new ArrayList<>();
        this.linkedList = new LinkedList<>();
        for (int i = 0; i < 10_000_000; i++)
        {
            arrayList.add(i);
            linkedList.add(i);
        }
    }

    @Benchmark
    public void binarySearchFromArrayList(Blackhole blackhole)
    {
        int randomValue = random.nextInt(10_000_000);
        int result = Collections
              .binarySearch(arrayList, randomValue);
        blackhole.consume(result);
    }

    @Benchmark
    public void binarySearchFromLinkedList(Blackhole blackhole)
    {
        int randomValue = random.nextInt(10_000_000);
        int result = Collections
                  .binarySearch(linkedList, randomValue);
        blackhole.consume(result);
    }

    public static void main(String[] args) throws RunnerException
    {
        final Options opt = new OptionsBuilder()
                .include(BinarySearch.class.getSimpleName())
                .build();
        new Runner(opt).run();
    }
}
```
https://weread.qq.com/web/reader/30b3225071eeefb430bb397kd67323c0227d67d8ab4fb04