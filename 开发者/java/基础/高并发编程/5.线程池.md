### Executor&ExecutorService详解

#### ThreadPoolExecutor详解
ThreadPoolExecutor是ExecutorService最为重要、最为常用的一个实现之一。
线程池主要解决了两个不同的问题：由于任务的异步提交，因此在执行大量的异步任务时可以提升系统性能；另外它还提供了限制和管理资源的方法，包括线程池中的工作线程、线程池任务队列中的任务，除此之外，每一个ThreadPoolExecutor还维护了一些基本的统计信息，比如已经完成的任务数量等。

1. ThreadPoolExecutor快速体验
```java
public static void main(String[] args)
        throws ExecutionException, InterruptedException
{
    // ① 创建ThreadPoolExecutor，7个构造参数
ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.DiscardPolicy());

    // ② 提交执行异步任务，不关注返回值
executor.execute(() -> System.out.println(" execute the runnable task"));

    // ③ 提交执行异步任务，关注返回值
Future<String> future = executor.submit(() -> " Execute the callable task and this is the result");

    // ④获取并输出callable任务的返回值
    System.out.println(future.get());
}
```

2. ThreadPoolExecutor的构造
```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
```
▪ corePoolSize：用于指定在线程池中维护的核心线程数量，即使当前线程池中的核心线程不工作，核心线程的数量也不会减少（在JDK1.6版本及以后可以通过设置允许核心线程超时的方法allowCoreThreadTimeOut来改变这种情况）​。
▪ maximumPoolSize：用于设置线程池中允许的线程数量的最大值。
▪ keepAliveTime：当线程池中的线程数量超过核心线程数并且处于空闲时，线程池将回收一部分线程让出系统资源，该参数可用于设置超过corePoolSize数量的线程在多长时间后被回收，与unit配合使用。
▪ TimeUnit：用于设定keepAliveTime的时间单位。
▪ workQueue：用于存放已提交至线程池但未被执行的任务。
▪ ThreadFactory：用于创建线程的工厂，开发者可以通过自定义ThreadFactory来创建线程，比如，根据业务名为线程命名、设置线程优先级、设置线程是否为守护线程等、设置线程所属的线程组等。
▪ RejectedExecutionHandler：当任务数量超过阻塞队列边界时，这个时候线程池就会拒绝新增的任务，该参数主要用于设置拒绝策略。ThreadPoolExecutor的构造比较复杂，除了其对每一个构造参数都有一定的要求之外（比如，不能为null）​，个别构造参数之间也存在一定的约束关系。
▪ TimeUnit、workQueue、ThreadFactory、RejectedExecutionHandler不能为null。
▪ corePoolSize可以设置为0，但不能小于0，并且corePoolSize不能大于线程的最大数量（maximumPoolSize）​。

3. 执行任务方法详解
▪ 线程池核心线程数量大于0，并且首次提交任务时，线程池会立即创建线程执行该任务，并且该任务不会被存入任务队列之中。
▪ 当线程池中的活跃（工作）线程大于等于核心线程数量并且任务队列未满时，任务队列中的任务不会立即执行，而是等待工作线程空闲时轮询任务队列以获取任务。
▪ 当任务队列已满且工作线程小于最大线程数量时，线程池会创建线程执行任务，但是线程数量不会超过最大线程数，下面将上一段代码的最大循环数修改为14（最大线程数+任务队列size）​，会发现同时有4个线程在工作。
▪ 当任务队列已满且线程池中的工作线程达到最大线程数量，并且此刻没有空闲的工作线程时，会执行任务拒绝策略，任务将以何种方式被拒绝完全取决于构造ThreadExecutorPool时指定的拒绝策略。若将执行任务的循环最大次数更改为15,再次执行时会发现只有14个任务被执行，第15个任务被丢弃（这里指定的拒绝策略为丢弃）​。
▪ 若线程池中的线程是空闲的且空闲时间达到指定的keepAliveTime时间，线程会被线程池回收（最多保留corePoolSize数量个线程）​，当然如果设置允许线程池中的核心线程超时，那么线程池中所有的工作线程都会被回收。

4. ThreadFactory详解
在ThreadExecutorPool的构造参数中提供了一个接口ThreadFactory，用于定义线程池中的线程（Thread）​，我们可以通过该接口指定线程的命名规则、优先级、是否为daemon守护线程等信息

5. 拒绝策略RejectedExecutionHandler
▪ DiscardPolicy：丢弃策略，任务会被直接无视丢弃而等不到执行，因此该策略需要慎重使用。
▪ AbortPolicy：中止策略，在线程池中使用该策略，在无法受理任务时会抛出拒绝执行异常RejectedExecutionException（运行时异常）​。
▪ DiscardOldestPolicy：丢弃任务队列中最老任务的策略。并不是所有的阻塞队列都是FIFO，也就是说最早进入任务队列中的任务并不一定是最早（老）的
▪ CallerRunsPolicy：调用者线程执行策略，前面的三种拒绝策略要么会在执行execute方法时抛出异常，要么会将任务丢弃。该策略不会导致新任务的丢失，但是任务会在当前线程中被阻塞地执行，也就是说任务不会由线程池中的工作线程执行。

![[Pasted image 20240923163718.png]]

#### ScheduledExecutorService详解
1. 定时任务
（1）Crontab
首先编写一个简单的shell脚本，并且将其保存至Linux操作系统的Crontab中。
（2）Timer/TimerTask
定时任务的执行基本上都会使用Timer和TimerTask来完成，目前在JDK官网这种方式已经不推荐使用了，替代方案就是我们在本节中将要介绍到的ScheduledThreadPoolExecutor。
（3）Quartz

#### 关闭ExecutorService
1. 有序关闭（shutdown）
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30,
        TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(10),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.DiscardPolicy());

// 提交10个任务
for (int i = 0; i < 10; i++)
{
    executor.execute(() ->
    {
        try
        {
            System.out.println(currentThread() + " is running.");
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    });
}
// 有序关闭
executor.shutdown();
// 执行shutdown后的断言
assert executor.isShutdown();    // 线程池被shutdown
assert executor.isTerminating(); // 线程池正在结束中
// 线程池未完全结束，因为任务队列中存在任务
assert !executor.isTerminated();
// 新提交的任务将不被接收，执行拒绝策略
executor.execute(() -> System.out.println("new task submit after shutdown"));

// 等待线程池结束，最多等待10分钟
executor.awaitTermination(10, TimeUnit.MINUTES);
assert executor.isShutdown();     // 线程池被shutdown
assert !executor.isTerminating(); // 线程池服务已经被终结
assert executor.isTerminated();   // 线程池服务已经被终结
```

2. 立即关闭（shutdownNow）
```java
for (int i = 0; i < 10; i++)
{
    executor.execute(() ->
    {
        try
        {
            System.out.println(currentThread() + " is running.");
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    });
}
// 执行立即关闭操作，返回值为未被执行的任务
List<Runnable> remainingRunnable = executor.shutdownNow();
System.out.println(remainingRunnable.size());
```

3. 组合关闭（shutdown&shutdownNow）
```java
void shutdownAndAwaitTermination(ExecutorService executor,
             long timeout, TimeUnit unit)
{
    // 首先执行executor的立即关闭方法
    executor.shutdown();
    try
    {
        // 如果在指定时间内线程池仍旧未被关闭
        if (!executor.awaitTermination(timeout, unit))
        {
            // 则执行立即关闭方法，排干任务队列中的任务
            executor.shutdownNow();
         // 如果线程池中的工作线程正在执行一个非常耗时且不可中断的方法，则中断失败
            if (!executor.awaitTermination(timeout, unit))
            {
                // print executor not terminated by normal.
            }
        }
    } catch (InterruptedException e)
    {
        // 如果当前线程被中断，并且捕获了中断信号，则执行立即关闭方法
        executor.shutdownNow();
        // 重新抛出中断信号
        Thread.currentThread().interrupt();
    }
}
```


### Executors详解
##### 1. FixedThreadPool
```java
// 创建ExecutorService，指定核心线程数
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>());
}

// 创建ExecutorService，指定核心线程数和ThreadFactory
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>(),
                            threadFactory);
}
```
通过源码我们不难发现，线程池的核心线程数和最大线程数是相等的，因此该线程池中的工作线程数将始终是固定的。任务队列为LinkedBlockingQueue（无边界）​，所以理论上提交至线程池的任务始终都会被执行，只有显式地执行线程池的关闭方法才能关闭线程池。

##### 2. SingleThreadPool
```java
// 创建只有一个工作线程的线程池
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>()));
}

// 创建只有一个工作线程的线程池，并指定ThreadFactory
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>(),
                            threadFactory));
}

static class FinalizableDelegatedExecutorService
    extends DelegatedExecutorService {
    FinalizableDelegatedExecutorService(ExecutorService executor) {
        super(executor);
}
    // 重写finalize方法
    protected void finalize() {
        // 当gc发生的时候，线程池会被执行shutdown
        super.shutdown();
    }
 }
```
SingleThreadPool是只有一个核心线程的线程池，但是Finalizable代理了该线程池，因此当线程池引用可被垃圾回收器回收时，线程池的shutdown方法会被执行，当然我们还是建议显式地调用线程池的关闭方法。

##### 3. CachedThreadPool
```java
// 创建Cached线程池
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                             60L, TimeUnit.SECONDS,
                             new SynchronousQueue<Runnable>());
}
// 创建Cached线程池并指定ThreadFactory
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                            60L, TimeUnit.SECONDS,
                            new SynchronousQueue<Runnable>(),
                            threadFactory);
}
```
CachedThreadPool根据需要创建新线程，但会重用以前构造的可用线程。该线程池通常会用于提高执行量大的、耗时较短的、异步任务程序的运行性能，在该线程池中，如果有可用的线程将被直接重用。如果没有可用的线程，则会创建一个新线程并将其添加到池中。未被使用且空闲时间超过60秒的线程将被终止并从线程池中移除，因此长时间空闲的线程不会消耗任何资源。

##### 4. ScheduledThreadPool
```java
// 构造指定核心线程数的ScheduledThreadPoolExecutor
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

// 指定核心线程数和ThreadFactory
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return
    new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```

##### 5. WorkStealingPool
```java
// 并发度等于CPU核数
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
        (Runtime.getRuntime().availableProcessors(),
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
// 允许指定并发度
public static ExecutorService newWorkStealingPool(int parallelism) {
    return new ForkJoinPool
        (parallelism,
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
```
WorkStealingPool是在JDK1.8版本中引入的线程池，它的返回结果是ForkJoinPool，而不是ScheduledThreadPoolService或ThreadPoolExecutor。
与其他线程池不同的是，WorkStealingPool中的工作线程会处理任务队列中与之对应的任务分片（Divide and conquer：分而治之）​，如果某个线程处理的任务执行比较耗时，那么它所负责的任务将会被其他线程“窃取”执行，进而提高并发处理的效率。


### Future和Callback

#### Future详解
▪ 密集型计算（数学和科学计算）​。
▪ 针对大数据的处理计算。
▪ 通过远程方法调用数据。
```java
ExecutorService executor = Executors.newSingleThreadExecutor();
// 提交任务，传入Callable接口，并且立即返回Future
Future<Double> future = executor.submit(() ->
{
    try
    {
        // 模拟任务执行耗时
        TimeUnit.SECONDS.sleep(20);
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }
    return 53.3d;
});
// 当前线程在等待结果结束的同时还可以做一些其他的事情
System.out.println("main thread do other thing.");
// 获取执行结果
System.out.println("The task result: " + future.get());

executor.shutdown();



package java.util.concurrent;
public interface Future<V>
{
    /**
    * 取消任务的执行，如果mayInterruptIfRunning为true，则工作线程将会被中断，
    * 否则即使执行了cancel方法，也会等待其完成，
    * 无论mayInterruptIfRunning为true还是false,isCancelled()都会为true,并且执行get 方法会抛异常
    */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
    *判断异步任务是否被取消
    */
    boolean isCancelled();

    /**
    * 判断异步任务的执行是否结束
    */
    boolean isDone();

    /**
    * 获取异步任务的执行结果，如果任务未运行结束，则该方法会使当前线程阻塞
    * 异步任务运行错误，调用get方法会抛出ExecutionException异常
    */
    V get() throws InterruptedException, ExecutionException;

    // 同get方法，但是允许设置最大超时时间
    V get(long timeout, TimeUnit unit)
        throws InterruptedException,
                ExecutionException, TimeoutException;
}
```


#### ExecutorService与Future
1. 提交Runnable类型任务
Submit方法除了可以提交执行Callable类型的任务之外，还可以提交Runnable类型的任务并且有两种重载形式，具体如下。
▪ `public Future<?> submit(Runnable task)：`提交Runnable类型的任务并且返回Future，待任务执行结束后，通过该future的get方法返回的结果始终为null。
▪ `public <T> Future<T> submit(Runnable task, T result)：`前一个提交Runnable类型的任务虽然会返回Future，但是任务结束之后通过future却拿不到任务的执行结果，而通过该submit方法则可以。

2. invokeAny
ExecutorService允许一次性提交一批任务，但是其只关心第一个完成的任务和结果，比如，我们要获取某城市当天天气情况的服务信息，在该服务中，我们需要调用不同的服务提供商接口，最快返回的那条数据将会是显示在APP或者Web前端的天气情况信息，这样做的好处是可以提高系统响应速度，提升用户体验，下面通过一个简单的例子来了解一下invokeAny的使用。
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
// 定义一批任务
List<Callable<Integer>> callables = new ArrayList<>();
for (int i = 0; i < 10; i++)
{
    callables.add(() ->
    {
        int random = ThreadLocalRandom.current().nextInt(30);
        // 随机休眠，模拟不同接口访问的不同时间开销
        TimeUnit.SECONDS.sleep(random);
        System.out.println("Task: " + random + " completed in Thread " + currentThread());
        return random;
    });
}
// 批量执行任务，但是只关心第一个完成的任务返回的结果
Integer result = executor.invokeAny(callables);
System.out.println("Result:"+result);
```

3. invokeAll
invokeAll方法同样可用于异步处理批量的任务，但是该方法关心所有异步任务的运行，invokeAll方法同样也是阻塞方法，一直等待所有的异步任务执行结束并返回结果。
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
// 定义批量任务
List<Callable<Integer>> callables = new ArrayList<>();
for (int i = 0; i < 10; i++)
{
    callables.add(() ->
    {
        int random = ThreadLocalRandom.current().nextInt(30);
        TimeUnit.SECONDS.sleep(random);
        System.out.println("Task: " + random + " completed in Thread " + currentThread());
        return random;
    });
}

try
{
    // 执行批量任务，返回所有异步任务的future集合
    List<Future<Integer>> futures = executor.invokeAll(callables);
    // 输出计算结果
    futures.forEach(future ->
    {
        try
        {
            System.out.println("Result: " + future.get());
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        } catch (ExecutionException e)
        {
            e.printStackTrace();
        }
    });
} catch (InterruptedException e)
{
    e.printStackTrace();
}
executor.shutdown();
```

#### Future的不足之处
Future的不足之处包括如下几项内容。
▪ 无法被动接收异步任务的计算结果：虽然我们可以主动将异步任务提交给线程池中的线程来执行，但是待异步任务结束后，主（当前）线程无法得到任务完成与否的通知，它需要通过get方法主动获取计算结果。
▪ Future间彼此孤立：有时某一个耗时很长的异步任务执行结束以后，你还想利用它返回的结果再做进一步的运算，该运算也会是一个异步任务，两者之间的关系需要程序开发人员手动进行绑定赋予，Future并不能将其形成一个任务流（pipeline）​，每一个Future彼此之间都是孤立的，但5.5节将要介绍的CompletableFuture就可以将多个Future串联起来形成任务流（pipeline）​。
▪ Future没有很好的错误处理机制：截至目前，如果某个异步任务在执行的过程中发生了异常错误，调用者无法被动获知，必须通过捕获get方法的异常才能知道异步任务是否出现了错误，从而再做进一步的处理。

#### Google Guava的Future
1. ListenableFuture
Guava提供了ListneningExecutorService，使用该ExecutorService提交执行异步任务时将返回ListenableFuture，通过该Future，我们可以注册回调接口。
```java
ExecutorService executorService = Executors.newCachedThreadPool();
// 通过 MoreExecutors定义ListeningExecutorService
ListeningExecutorService decoratorService =
        MoreExecutors.listeningDecorator(executorService);
// 提交异步任务并且返回ListenableFuture
ListenableFuture<String> listenableFuture =
    decoratorService.submit(() ->
{
    TimeUnit.SECONDS.sleep(10);
    return "I am the result";
});

// 注册回调函数，待任务执行完成后，该回调函数将被调用执行
listenableFuture.addListener(() ->
{
    System.out.println("The task completed.");
    try
    {
        System.out.println("The task result:"
                           + listenableFuture.get());
        decoratorService.shutdown();
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    } catch (ExecutionException e)
    {
        System.out.println("The task failed");
    }
}, decoratorService);
```

2. FutureCallback
除了ListenableFuture之外，还可以注册FutureCallback，相比前者用Runnable接口作为回调接口，FutureCallback提供的回调方式则更为直观。
```java
ExecutorService executorService = Executors.newCachedThreadPool();

ListeningExecutorService decoratorService =
        MoreExecutors.listeningDecorator(executorService);
// 提交任务返回listenableFuture
ListenableFuture<String> listenableFuture =
    decoratorService.submit(() ->
{
    TimeUnit.SECONDS.sleep(10);
    return "I am the result";
});

// 使用Futures增加callback
Futures.addCallback(listenableFuture, new FutureCallback<String>()
{
    // 任务执行成功会被回调
    @Override
    public void onSuccess(@Nullable String result)
    {
        System.out.println("The Task completed and result:" + result);
        decoratorService.shutdown();
    }

    // 任务执行失败会被回调
    @Override
    public void onFailure(Throwable t)
    {
        t.printStackTrace();
    }
}, decoratorService);
```


### ForkJoinPool详解
