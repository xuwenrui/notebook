### Executor&ExecutorService详解

#### ThreadPoolExecutor详解
ThreadPoolExecutor是ExecutorService最为重要、最为常用的一个实现之一。
线程池主要解决了两个不同的问题：由于任务的异步提交，因此在执行大量的异步任务时可以提升系统性能；另外它还提供了限制和管理资源的方法，包括线程池中的工作线程、线程池任务队列中的任务，除此之外，每一个ThreadPoolExecutor还维护了一些基本的统计信息，比如已经完成的任务数量等。

1. ThreadPoolExecutor快速体验
```java
public static void main(String[] args)
        throws ExecutionException, InterruptedException
{
    // ① 创建ThreadPoolExecutor，7个构造参数
ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.DiscardPolicy());

    // ② 提交执行异步任务，不关注返回值
executor.execute(() -> System.out.println(" execute the runnable task"));

    // ③ 提交执行异步任务，关注返回值
Future<String> future = executor.submit(() -> " Execute the callable task and this is the result");

    // ④获取并输出callable任务的返回值
    System.out.println(future.get());
}
```

2. ThreadPoolExecutor的构造
```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
```
▪ corePoolSize：用于指定在线程池中维护的核心线程数量，即使当前线程池中的核心线程不工作，核心线程的数量也不会减少（在JDK1.6版本及以后可以通过设置允许核心线程超时的方法allowCoreThreadTimeOut来改变这种情况）​。
▪ maximumPoolSize：用于设置线程池中允许的线程数量的最大值。
▪ keepAliveTime：当线程池中的线程数量超过核心线程数并且处于空闲时，线程池将回收一部分线程让出系统资源，该参数可用于设置超过corePoolSize数量的线程在多长时间后被回收，与unit配合使用。
▪ TimeUnit：用于设定keepAliveTime的时间单位。
▪ workQueue：用于存放已提交至线程池但未被执行的任务。
▪ ThreadFactory：用于创建线程的工厂，开发者可以通过自定义ThreadFactory来创建线程，比如，根据业务名为线程命名、设置线程优先级、设置线程是否为守护线程等、设置线程所属的线程组等。
▪ RejectedExecutionHandler：当任务数量超过阻塞队列边界时，这个时候线程池就会拒绝新增的任务，该参数主要用于设置拒绝策略。ThreadPoolExecutor的构造比较复杂，除了其对每一个构造参数都有一定的要求之外（比如，不能为null）​，个别构造参数之间也存在一定的约束关系。
▪ TimeUnit、workQueue、ThreadFactory、RejectedExecutionHandler不能为null。
▪ corePoolSize可以设置为0，但不能小于0，并且corePoolSize不能大于线程的最大数量（maximumPoolSize）​。

3. 执行任务方法详解
▪ 线程池核心线程数量大于0，并且首次提交任务时，线程池会立即创建线程执行该任务，并且该任务不会被存入任务队列之中。
▪ 当线程池中的活跃（工作）线程大于等于核心线程数量并且任务队列未满时，任务队列中的任务不会立即执行，而是等待工作线程空闲时轮询任务队列以获取任务。
▪ 当任务队列已满且工作线程小于最大线程数量时，线程池会创建线程执行任务，但是线程数量不会超过最大线程数，下面将上一段代码的最大循环数修改为14（最大线程数+任务队列size）​，会发现同时有4个线程在工作。
▪ 当任务队列已满且线程池中的工作线程达到最大线程数量，并且此刻没有空闲的工作线程时，会执行任务拒绝策略，任务将以何种方式被拒绝完全取决于构造ThreadExecutorPool时指定的拒绝策略。若将执行任务的循环最大次数更改为15,再次执行时会发现只有14个任务被执行，第15个任务被丢弃（这里指定的拒绝策略为丢弃）​。
▪ 若线程池中的线程是空闲的且空闲时间达到指定的keepAliveTime时间，线程会被线程池回收（最多保留corePoolSize数量个线程）​，当然如果设置允许线程池中的核心线程超时，那么线程池中所有的工作线程都会被回收。

4. ThreadFactory详解
在ThreadExecutorPool的构造参数中提供了一个接口ThreadFactory，用于定义线程池中的线程（Thread）​，我们可以通过该接口指定线程的命名规则、优先级、是否为daemon守护线程等信息

5. 拒绝策略RejectedExecutionHandler
▪ DiscardPolicy：丢弃策略，任务会被直接无视丢弃而等不到执行，因此该策略需要慎重使用。
▪ AbortPolicy：中止策略，在线程池中使用该策略，在无法受理任务时会抛出拒绝执行异常RejectedExecutionException（运行时异常）​。
▪ DiscardOldestPolicy：丢弃任务队列中最老任务的策略。并不是所有的阻塞队列都是FIFO，也就是说最早进入任务队列中的任务并不一定是最早（老）的
▪ CallerRunsPolicy：调用者线程执行策略，前面的三种拒绝策略要么会在执行execute方法时抛出异常，要么会将任务丢弃。该策略不会导致新任务的丢失，但是任务会在当前线程中被阻塞地执行，也就是说任务不会由线程池中的工作线程执行。

![[Pasted image 20240923163718.png]]

#### ScheduledExecutorService详解
1. 定时任务
（1）Crontab
首先编写一个简单的shell脚本，并且将其保存至Linux操作系统的Crontab中。
（2）Timer/TimerTask
定时任务的执行基本上都会使用Timer和TimerTask来完成，目前在JDK官网这种方式已经不推荐使用了，替代方案就是我们在本节中将要介绍到的ScheduledThreadPoolExecutor。
（3）Quartz

#### 关闭ExecutorService
1. 有序关闭（shutdown）
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30,
        TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(10),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.DiscardPolicy());

// 提交10个任务
for (int i = 0; i < 10; i++)
{
    executor.execute(() ->
    {
        try
        {
            System.out.println(currentThread() + " is running.");
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    });
}
// 有序关闭
executor.shutdown();
// 执行shutdown后的断言
assert executor.isShutdown();    // 线程池被shutdown
assert executor.isTerminating(); // 线程池正在结束中
// 线程池未完全结束，因为任务队列中存在任务
assert !executor.isTerminated();
// 新提交的任务将不被接收，执行拒绝策略
executor.execute(() -> System.out.println("new task submit after shutdown"));

// 等待线程池结束，最多等待10分钟
executor.awaitTermination(10, TimeUnit.MINUTES);
assert executor.isShutdown();     // 线程池被shutdown
assert !executor.isTerminating(); // 线程池服务已经被终结
assert executor.isTerminated();   // 线程池服务已经被终结
```

2. 立即关闭（shutdownNow）
```java
for (int i = 0; i < 10; i++)
{
    executor.execute(() ->
    {
        try
        {
            System.out.println(currentThread() + " is running.");
            TimeUnit.SECONDS.sleep(10);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    });
}
// 执行立即关闭操作，返回值为未被执行的任务
List<Runnable> remainingRunnable = executor.shutdownNow();
System.out.println(remainingRunnable.size());
```

3. 组合关闭（shutdown&shutdownNow）
```java
void shutdownAndAwaitTermination(ExecutorService executor,
             long timeout, TimeUnit unit)
{
    // 首先执行executor的立即关闭方法
    executor.shutdown();
    try
    {
        // 如果在指定时间内线程池仍旧未被关闭
        if (!executor.awaitTermination(timeout, unit))
        {
            // 则执行立即关闭方法，排干任务队列中的任务
            executor.shutdownNow();
         // 如果线程池中的工作线程正在执行一个非常耗时且不可中断的方法，则中断失败
            if (!executor.awaitTermination(timeout, unit))
            {
                // print executor not terminated by normal.
            }
        }
    } catch (InterruptedException e)
    {
        // 如果当前线程被中断，并且捕获了中断信号，则执行立即关闭方法
        executor.shutdownNow();
        // 重新抛出中断信号
        Thread.currentThread().interrupt();
    }
}
```


### Executors详解
##### 1. FixedThreadPool
```java
// 创建ExecutorService，指定核心线程数
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>());
}

// 创建ExecutorService，指定核心线程数和ThreadFactory
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>(),
                            threadFactory);
}
```
通过源码我们不难发现，线程池的核心线程数和最大线程数是相等的，因此该线程池中的工作线程数将始终是固定的。任务队列为LinkedBlockingQueue（无边界）​，所以理论上提交至线程池的任务始终都会被执行，只有显式地执行线程池的关闭方法才能关闭线程池。

##### 2. SingleThreadPool
```java
// 创建只有一个工作线程的线程池
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>()));
}

// 创建只有一个工作线程的线程池，并指定ThreadFactory
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>(),
                            threadFactory));
}

static class FinalizableDelegatedExecutorService
    extends DelegatedExecutorService {
    FinalizableDelegatedExecutorService(ExecutorService executor) {
        super(executor);
}
    // 重写finalize方法
    protected void finalize() {
        // 当gc发生的时候，线程池会被执行shutdown
        super.shutdown();
    }
 }
```
SingleThreadPool是只有一个核心线程的线程池，但是Finalizable代理了该线程池，因此当线程池引用可被垃圾回收器回收时，线程池的shutdown方法会被执行，当然我们还是建议显式地调用线程池的关闭方法。

##### 3. CachedThreadPool
```java
// 创建Cached线程池
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                             60L, TimeUnit.SECONDS,
                             new SynchronousQueue<Runnable>());
}
// 创建Cached线程池并指定ThreadFactory
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                            60L, TimeUnit.SECONDS,
                            new SynchronousQueue<Runnable>(),
                            threadFactory);
}
```
CachedThreadPool根据需要创建新线程，但会重用以前构造的可用线程。该线程池通常会用于提高执行量大的、耗时较短的、异步任务程序的运行性能，在该线程池中，如果有可用的线程将被直接重用。如果没有可用的线程，则会创建一个新线程并将其添加到池中。未被使用且空闲时间超过60秒的线程将被终止并从线程池中移除，因此长时间空闲的线程不会消耗任何资源。

##### 4. ScheduledThreadPool
```java
// 构造指定核心线程数的ScheduledThreadPoolExecutor
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

// 指定核心线程数和ThreadFactory
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return
    new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```

##### 5. WorkStealingPool
```java
// 并发度等于CPU核数
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
        (Runtime.getRuntime().availableProcessors(),
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
// 允许指定并发度
public static ExecutorService newWorkStealingPool(int parallelism) {
    return new ForkJoinPool
        (parallelism,
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
```
WorkStealingPool是在JDK1.8版本中引入的线程池，它的返回结果是ForkJoinPool，而不是ScheduledThreadPoolService或ThreadPoolExecutor。
与其他线程池不同的是，WorkStealingPool中的工作线程会处理任务队列中与之对应的任务分片（Divide and conquer：分而治之）​，如果某个线程处理的任务执行比较耗时，那么它所负责的任务将会被其他线程“窃取”执行，进而提高并发处理的效率。


### Future和Callback

#### Future详解
▪ 密集型计算（数学和科学计算）​。
▪ 针对大数据的处理计算。
▪ 通过远程方法调用数据。
```java
ExecutorService executor = Executors.newSingleThreadExecutor();
// 提交任务，传入Callable接口，并且立即返回Future
Future<Double> future = executor.submit(() ->
{
    try
    {
        // 模拟任务执行耗时
        TimeUnit.SECONDS.sleep(20);
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }
    return 53.3d;
});
// 当前线程在等待结果结束的同时还可以做一些其他的事情
System.out.println("main thread do other thing.");
// 获取执行结果
System.out.println("The task result: " + future.get());

executor.shutdown();
```