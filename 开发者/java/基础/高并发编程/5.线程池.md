### Executor&ExecutorService详解

#### ThreadPoolExecutor详解
ThreadPoolExecutor是ExecutorService最为重要、最为常用的一个实现之一。
线程池主要解决了两个不同的问题：由于任务的异步提交，因此在执行大量的异步任务时可以提升系统性能；另外它还提供了限制和管理资源的方法，包括线程池中的工作线程、线程池任务队列中的任务，除此之外，每一个ThreadPoolExecutor还维护了一些基本的统计信息，比如已经完成的任务数量等。

1. ThreadPoolExecutor快速体验
```java
public static void main(String[] args)
        throws ExecutionException, InterruptedException
{
    // ① 创建ThreadPoolExecutor，7个构造参数
ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 4, 30,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.DiscardPolicy());

    // ② 提交执行异步任务，不关注返回值
executor.execute(() -> System.out.println(" execute the runnable task"));

    // ③ 提交执行异步任务，关注返回值
Future<String> future = executor.submit(() -> " Execute the callable task and this is the result");

    // ④获取并输出callable任务的返回值
    System.out.println(future.get());
}
```

2. ThreadPoolExecutor的构造
```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
```
▪ corePoolSize：用于指定在线程池中维护的核心线程数量，即使当前线程池中的核心线程不工作，核心线程的数量也不会减少（在JDK1.6版本及以后可以通过设置允许核心线程超时的方法allowCoreThreadTimeOut来改变这种情况）​。
▪ maximumPoolSize：用于设置线程池中允许的线程数量的最大值。
▪ keepAliveTime：当线程池中的线程数量超过核心线程数并且处于空闲时，线程池将回收一部分线程让出系统资源，该参数可用于设置超过corePoolSize数量的线程在多长时间后被回收，与unit配合使用。
▪ TimeUnit：用于设定keepAliveTime的时间单位。
▪ workQueue：用于存放已提交至线程池但未被执行的任务。
▪ ThreadFactory：用于创建线程的工厂，开发者可以通过自定义ThreadFactory来创建线程，比如，根据业务名为线程命名、设置线程优先级、设置线程是否为守护线程等、设置线程所属的线程组等。
▪ RejectedExecutionHandler：当任务数量超过阻塞队列边界时，这个时候线程池就会拒绝新增的任务，该参数主要用于设置拒绝策略。ThreadPoolExecutor的构造比较复杂，除了其对每一个构造参数都有一定的要求之外（比如，不能为null）​，个别构造参数之间也存在一定的约束关系。
▪ TimeUnit、workQueue、ThreadFactory、RejectedExecutionHandler不能为null。
▪ corePoolSize可以设置为0，但不能小于0，并且corePoolSize不能大于线程的最大数量（maximumPoolSize）​。

3. 执行任务方法详解
▪ 线程池核心线程数量大于0，并且首次提交任务时，线程池会立即创建线程执行该任务，并且该任务不会被存入任务队列之中。
▪ 当线程池中的活跃（工作）线程大于等于核心线程数量并且任务队列未满时，任务队列中的任务不会立即执行，而是等待工作线程空闲时轮询任务队列以获取任务。
▪ 当任务队列已满且工作线程小于最大线程数量时，线程池会创建线程执行任务，但是线程数量不会超过最大线程数，下面将上一段代码的最大循环数修改为14（最大线程数+任务队列size）​，会发现同时有4个线程在工作。
▪ 当任务队列已满且线程池中的工作线程达到最大线程数量，并且此刻没有空闲的工作线程时，会执行任务拒绝策略，任务将以何种方式被拒绝完全取决于构造ThreadExecutorPool时指定的拒绝策略。若将执行任务的循环最大次数更改为15,再次执行时会发现只有14个任务被执行，第15个任务被丢弃（这里指定的拒绝策略为丢弃）​。
▪ 若线程池中的线程是空闲的且空闲时间达到指定的keepAliveTime时间，线程会被线程池回收（最多保留corePoolSize数量个线程）​，当然如果设置允许线程池中的核心线程超时，那么线程池中所有的工作线程都会被回收。

4. ThreadFactory详解
在ThreadExecutorPool的构造参数中提供了一个接口ThreadFactory，用于定义线程池中的线程（Thread）​，我们可以通过该接口指定线程的命名规则、优先级、是否为daemon守护线程等信息

5. 拒绝策略RejectedExecutionHandler
▪ DiscardPolicy：丢弃策略，任务会被直接无视丢弃而等不到执行，因此该策略需要慎重使用。
▪ AbortPolicy：中止策略，在线程池中使用该策略，在无法受理任务时会抛出拒绝执行异常RejectedExecutionException（运行时异常）​。
▪ DiscardOldestPolicy：丢弃任务队列中最老任务的策略。并不是所有的阻塞队列都是FIFO，也就是说最早进入任务队列中的任务并不一定是最早（老）的
▪ CallerRunsPolicy：调用者线程执行策略，前面的三种拒绝策略要么会在执行execute方法时抛出异常，要么会将任务丢弃。该策略不会导致新任务的丢失，但是任务会在当前线程中被阻塞地执行，也就是说任务不会由线程池中的工作线程执行。

![[Pasted image 20240923163718.png]]