### Metrics快速入门
Metrics是一个非常轻量级的框架，其核心jar包只有134KB的大小，在使用的过程中只需要通过Maven对其进行引入即可。

#### 如何监控度量应用程序
在将应用程序部署到生产环境中之后，我们一般会很想知道某些重要指标的数据，比如当前有多少用户在线、有哪些服务的调用出现了问题、某个服务接口被调用了多少次、业务受理的成功率（或失败率）​、服务接口的平均响应时长等。当然我们有多种办法实现这样的功能，比如以下几种。
▪ 实时更新所要监控的数据并将其记录在数据库中：这种方式毫无疑问可以实现我们想要的性能数据，但是可能会对数据库形成一定的压力，并且让业务程序与性能监控程序产生耦合。
▪ 将所要监控的数据写入日志：通过输出日志的方式记录所要监控的数据，然后由另外的程序（Apache Flume、LogStash、splunk等）采集日志文本，经过分析之后存入关系型数据库中。这种解决方案目前应用比较广泛，因为它做到了真正的无侵入性，应用程序根本不知道监控程序的存在，只需要根据一定的规范打印日志即可。
▪ 采用JMX的方式监控性能数据：将需要监控的性能数据封装成符合JMX规范的MBean，这样我们就可以借助于JMX客户端程序（比如jconsole、jvisualvm）进行远程查看。
▪ 提供嵌入式的RESTful接口：如同JMX监控的方式一样，我们可以提供RESTful服务接口，将需要特别监控的数据封装成Resource，对外提供HTTP的访问。
▪ 借助于Metrics工具集：收集性能监控数据，然后将数据交给Reporter进行不同形式的展现，甚至还可以将Metrics收集到的数据与目前比较强大的运维监控工具Ganglia、Graphite等结合在一起。
虽然Metrics收集数据也需要在应用程序中侵入性能数据收集的相关代码，但是这种方式基本上不会影响业务程序的运行，因为它对度量数据的report完全是以异步的方式进行的。

#### Metrics环境搭建
Metrics提供了非常强大的性能数据收集方式，并且在Metrics内部集成了CSV、JMX、Log、Console四大Reporter，除此之外，Reporter是一个非常易于扩展的接口，使用者可以通过自定义Reporter的形式将Metrics收集到的数据展示（存储）在任何地方。
Metrics的官网地址：https:// metrics.dropwizard.io/3.1.0/
Metrics就是一个jar包，我们可以通过增加pom的方式为应用程序加入依赖。
```xml
<dependency>
    <groupId>io.dropwizard.metrics</groupId>
    <artifactId>metrics-core</artifactId>
    <version>3.2.6</version>
</dependency>
```

### 五大Metric详解
Metrics包含三大组件，分别是Reporter、Metric及MetricRegistry。Metrics组件关系如图7-1所示。
![[Pasted image 20240929114852.png|600]]
首先，在应用程序中植入Metric用于收集系统运行时产生的性能数据，各个Metric被注册在MetricRegistry中，Reporter从MetricRegistry中获取各个Metric的数据，然后进行输出或存储等操作。

Metrics为我们提供了五大可用的Metric组件，本节将详细介绍每一个Metric的作用及用法。

#### Meter
Meter主要用来测量一组事件发生的速率（见图7-2）​，比如，我们可以用它来度量某个服务接口被调用的频率，甚至可以用它来度量某些网络操作的吞吐量。
![[Pasted image 20240929115058.png|450]]
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.Meter;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.TimeUnit;

import static java.util.concurrent.ThreadLocalRandom.current;

public class MeterExample
{
    // 1. 定义MetricRegistry
    private final static MetricRegistry registry = new MetricRegistry();
    // 2. 定义名为tqs的Meter
    private final static Meter requestMeter = registry.meter("tqs");
    // 3. 定义名为volume的Meter
    private final static Meter sizeMeter = registry.meter("volume");

    public static void main(String[] args)
    {
        // 4. 定义ConsoleReporter并且设定相关的参数
        ConsoleReporter reporter = ConsoleReporter.forRegistry(registry)
                .convertRatesTo(TimeUnit.MINUTES)
                .convertDurationsTo(TimeUnit.MINUTES).build();
        // 5. 启动Reporter，每隔10秒运行一次
        reporter.start(10, TimeUnit.SECONDS);
        // 6. 提供在线服务
        for (; ; )
        {
            // 7. 上传数据
            upload(new byte[current().nextInt(1000)]);
            // 8. 随机休眠
            randomSleep();
        }
    }
    // 上传数据到服务器
    private static void upload(byte[] request)
    {
        // 9. 对每一次的update方法调用一次mark
        requestMeter.mark();
        // 10. 对上传的数据长度进行mark
        sizeMeter.mark(request.length);
    }
    private static void randomSleep()
    {
        try
        {
            TimeUnit.SECONDS.sleep(current().nextInt(10));
        } catch (InterruptedException e)
        {
        }
    }
}
```
1）定义一个MetricRegistry，它的作用就是一个Metric的注册表，其将所有的Metric注册在该表中，以方便Reporter对其进行获取。
2）定义了一个用于度量TQS的Meter，通过registry创建meter，除了会创建出一个Metric之外，还会将创建好的Metric顺便注册到注册表中。
3）同2，定义了一个用于度量VOLUME的Meter。
4）注释4处定义了一个ConsoleReporter，并且指定了将从哪个registry中获取Metric的度量数据。
5）启动Reporter，每隔10秒的时间将会对Registry中的所有Metric进行一次report。
6）注释6处采用无限循环的方式模拟程序提供了不间断的服务。
7）注释7处调用数据上传方法，上传数据的大小是根据随机数获得的。
8）注释8处短暂休眠一段随机的时间。
9）对upload方法的每一次调用都会对tqs meter进行一次mark，也就意味着对其进行了一次计数。
10）对upload方法的每一次调用，都会通过volume meter对上传上来的字节流进行计数，以用于度量吞吐量。

```
-- Meters --------------------------------------------------
tqs
             count = 7
         mean rate = 20.75 events/minute
     1-minute rate = 13.62 events/minute
     5-minute rate = 12.38 events/minute
    15-minute rate = 12.13 events/minute
volume
             count = 4467
         mean rate = 13232.44 events/minute
     1-minute rate = 8433.26 events/minute
     5-minute rate = 7344.22 events/minute
    15-minute rate = 7123.20 events/minute


18-12-8 20:17:22 ===========================================

-- Meters ----------------------------------------------------
tqs
             count = 9
         mean rate = 17.85 events/minute
     1-minute rate = 13.37 events/minute
     5-minute rate = 12.37 events/minute
    15-minute rate = 12.13 events/minute
volume
             count = 5112
         mean rate = 10140.89 events/minute
     1-minute rate = 7554.72 events/minute
     5-minute rate = 7194.24 events/minute
    15-minute rate = 7075.20 events/minute


18-12-8 20:17:32 =======================================

-- Meters ---------------------------------------------------
tqs
             count = 10
         mean rate = 14.88 events/minute
     1-minute rate = 13.16 events/minute
     5-minute rate = 12.36 events/minute
    15-minute rate = 12.13 events/minute
volume
             count = 5189
         mean rate = 7723.02 events/minute
     1-minute rate = 6963.15 events/minute
     5-minute rate = 7082.89 events/minute
    15-minute rate = 7039.17 events/minute
```
通过Reporter的输出我们可以看到，upload方法调用了10次，通过EWMA模型（ExponentiallyWeighted Moving-Average，指数加权移动平均值的控制图）的统计可以得出，这些数据一分钟的平均速率将是14.88次，每分钟上传文件的平均字节数是7723.02字节。

#### Gauge
Gauge是最简单的Metric类型，如图7-3所示，它只返回一个Value值，比如，它可以用来查看某个关键队列在某个时刻的size，或者用来查看当前网站的在线人数等。
![[Pasted image 20240929115457.png|356]]
1. Simple Gauge详解
Simple Gauge就像它的名字所表明的那样，非常简单，仅会返回需要我们关注的值。比如，在block queue中，多线程同时对其进行pop及add操作，如果想要知道在某个时刻该队列的size是多少，则可以借助于Simple Gauge来进行实现。
```java
public interface Gauge<T> extends Metric {
    /**
     * Returns the metric's current value.
     *
     * @return the metric's current value
     */
    T getValue();
}
```
由上述代码段可知Gauge接口只有一个方法getValue()，因此我们可以将该接口称为FunctionalInterface。好了，接下来就来写一个获取queue size的metric应用程序。
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.Gauge;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

public class SimpleGaugeExample
{
    // 定义一个metric registry
    private static final MetricRegistry metricRegistry = new MetricRegistry();
    // 定义Console Reporter
    private static final ConsoleReporter reporter = ConsoleReporter.forRegistry(metricRegistry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();
    // 定义一个双向队列，这个队列是需要监控的队列
    private static final BlockingDeque<Long> queue = new LinkedBlockingDeque<>(1_000);

    public static void main(String[] args)
    {
        // 定义一个Simple Gauge，并且将其注册到registry中
        // Gauge的实现仅仅是返回queue的size，queue::size静态推导
        metricRegistry.register(MetricRegistry.name(SimpleGaugeExample.class, "queue-size"), (Gauge<Integer>) queue::size);

        reporter.start(1, TimeUnit.SECONDS);

        // 启动一个线程向队列中不断放入数据
        new Thread(() ->
        {
            for (; ; )
            {
                randomSleep();
                queue.add(System.nanoTime());
            }
        }).start();

        // 启动另外一个线程，从队列中不断地poll数据
        new Thread(() ->
        {
            for (; ; )
            {
                randomSleep();
                queue.poll();
            }
        }).start();
    }

   // 随机休眠
    private static void randomSleep()
    {
        try
        {
            TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(6));
        } catch (InterruptedException e)
        {
        }
    }
}
```
```

```

```log
-- Gauges ----------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 1


18-12-8 21:30:45 =======================

-- Gauges ----------------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 3


18-12-8 21:30:46 ==========================

-- Gauges ------------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 3


18-12-8 21:30:47 =========================

-- Gauges ---------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 2


18-12-8 21:30:48 ======================

-- Gauges -------------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 2
```
通过输出信息，可以看到queue size的变化。通过这个度量数据，我们很容易就能发现生产者线程和消费者线程的处理速度，以及队列出现的积压情况，这对我们分析工作线程的运行性能非常重要。

2. JMX Attribute Gauge详解
除了在应用程序中可以定义很多符合JMX标准的MBean之外，JDK还为我们提供了非常多的MBean（如图7-4所示）​，用于诊断JVM的一些运行指标数据。如果想要获取JVM的MBean，则需要借助于jconsole、jvisualvm、jprofiler这样的工具；如果想要远程查看，那么还必须打开JMX服务端口。
```java
-Djava.rmi.server.hostname=192.168.2.142
-Dcom.sun.management.jmxremote.port=12345
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
```
![[Pasted image 20240929115932.png]]
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.JmxAttributeGauge;
import com.codahale.metrics.MetricRegistry;

import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import java.util.concurrent.TimeUnit;

public class JmxAttributeGaugeExample
{

    // 定义metric registry
    private final static MetricRegistry registry = new MetricRegistry();
    // 构造ConsoleReporter
    private final static ConsoleReporter reporter = ConsoleReporter
            .forRegistry(registry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();

    public static void main(String[] args)
            throws MalformedObjectNameException, InterruptedException
    {
        // 启动Reporter，每隔10秒的时间输出一次数据
        reporter.start(10, TimeUnit.SECONDS);

        // 注册JmxAttributeGauge，主要输出堆内存的使用情况
        registry.register(MetricRegistry.name(JmxAttributeGaugeExample.class, "Heap                            Memory"), new JmxAttributeGauge(new ObjectName("java.                            lang:type=Memory"), "HeapMemoryUsage"
        ));

        // 注册JmxAttributeGauge，主要输出非堆内存的使用情况
        registry.register(MetricRegistry.name(JmxAttributeGaugeExample.class, "NonHeap                            MemoryUsage"), new JmxAttributeGauge(new ObjectName("java.                            lang:type=Memory"), "NonHeapMemoryUsage"
        ));

        // 让主线程join，目的是不让程序退出
        Thread.currentThread().join();
    }
}
```

3. Ratio Gauge详解
