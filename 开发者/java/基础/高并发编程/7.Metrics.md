### Metrics快速入门
Metrics是一个非常轻量级的框架，其核心jar包只有134KB的大小，在使用的过程中只需要通过Maven对其进行引入即可。

#### 如何监控度量应用程序
在将应用程序部署到生产环境中之后，我们一般会很想知道某些重要指标的数据，比如当前有多少用户在线、有哪些服务的调用出现了问题、某个服务接口被调用了多少次、业务受理的成功率（或失败率）​、服务接口的平均响应时长等。当然我们有多种办法实现这样的功能，比如以下几种。
▪ 实时更新所要监控的数据并将其记录在数据库中：这种方式毫无疑问可以实现我们想要的性能数据，但是可能会对数据库形成一定的压力，并且让业务程序与性能监控程序产生耦合。
▪ 将所要监控的数据写入日志：通过输出日志的方式记录所要监控的数据，然后由另外的程序（Apache Flume、LogStash、splunk等）采集日志文本，经过分析之后存入关系型数据库中。这种解决方案目前应用比较广泛，因为它做到了真正的无侵入性，应用程序根本不知道监控程序的存在，只需要根据一定的规范打印日志即可。
▪ 采用JMX的方式监控性能数据：将需要监控的性能数据封装成符合JMX规范的MBean，这样我们就可以借助于JMX客户端程序（比如jconsole、jvisualvm）进行远程查看。
▪ 提供嵌入式的RESTful接口：如同JMX监控的方式一样，我们可以提供RESTful服务接口，将需要特别监控的数据封装成Resource，对外提供HTTP的访问。
▪ 借助于Metrics工具集：收集性能监控数据，然后将数据交给Reporter进行不同形式的展现，甚至还可以将Metrics收集到的数据与目前比较强大的运维监控工具Ganglia、Graphite等结合在一起。
虽然Metrics收集数据也需要在应用程序中侵入性能数据收集的相关代码，但是这种方式基本上不会影响业务程序的运行，因为它对度量数据的report完全是以异步的方式进行的。

#### Metrics环境搭建
Metrics提供了非常强大的性能数据收集方式，并且在Metrics内部集成了CSV、JMX、Log、Console四大Reporter，除此之外，Reporter是一个非常易于扩展的接口，使用者可以通过自定义Reporter的形式将Metrics收集到的数据展示（存储）在任何地方。
Metrics的官网地址：https:// metrics.dropwizard.io/3.1.0/
Metrics就是一个jar包，我们可以通过增加pom的方式为应用程序加入依赖。
```xml
<dependency>
    <groupId>io.dropwizard.metrics</groupId>
    <artifactId>metrics-core</artifactId>
    <version>3.2.6</version>
</dependency>
```

### 五大Metric详解
Metrics包含三大组件，分别是Reporter、Metric及MetricRegistry。Metrics组件关系如图7-1所示。
![[Pasted image 20240929114852.png|600]]
首先，在应用程序中植入Metric用于收集系统运行时产生的性能数据，各个Metric被注册在MetricRegistry中，Reporter从MetricRegistry中获取各个Metric的数据，然后进行输出或存储等操作。

Metrics为我们提供了五大可用的Metric组件，本节将详细介绍每一个Metric的作用及用法。

#### Meter
Meter主要用来测量一组事件发生的速率（见图7-2）​，比如，我们可以用它来度量某个服务接口被调用的频率，甚至可以用它来度量某些网络操作的吞吐量。
![[Pasted image 20240929115058.png|450]]
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.Meter;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.TimeUnit;

import static java.util.concurrent.ThreadLocalRandom.current;

public class MeterExample
{
    // 1. 定义MetricRegistry
    private final static MetricRegistry registry = new MetricRegistry();
    // 2. 定义名为tqs的Meter
    private final static Meter requestMeter = registry.meter("tqs");
    // 3. 定义名为volume的Meter
    private final static Meter sizeMeter = registry.meter("volume");

    public static void main(String[] args)
    {
        // 4. 定义ConsoleReporter并且设定相关的参数
        ConsoleReporter reporter = ConsoleReporter.forRegistry(registry)
                .convertRatesTo(TimeUnit.MINUTES)
                .convertDurationsTo(TimeUnit.MINUTES).build();
        // 5. 启动Reporter，每隔10秒运行一次
        reporter.start(10, TimeUnit.SECONDS);
        // 6. 提供在线服务
        for (; ; )
        {
            // 7. 上传数据
            upload(new byte[current().nextInt(1000)]);
            // 8. 随机休眠
            randomSleep();
        }
    }
    // 上传数据到服务器
    private static void upload(byte[] request)
    {
        // 9. 对每一次的update方法调用一次mark
        requestMeter.mark();
        // 10. 对上传的数据长度进行mark
        sizeMeter.mark(request.length);
    }
    private static void randomSleep()
    {
        try
        {
            TimeUnit.SECONDS.sleep(current().nextInt(10));
        } catch (InterruptedException e)
        {
        }
    }
}
```
1）定义一个MetricRegistry，它的作用就是一个Metric的注册表，其将所有的Metric注册在该表中，以方便Reporter对其进行获取。
2）定义了一个用于度量TQS的Meter，通过registry创建meter，除了会创建出一个Metric之外，还会将创建好的Metric顺便注册到注册表中。
3）同2，定义了一个用于度量VOLUME的Meter。
4）注释4处定义了一个ConsoleReporter，并且指定了将从哪个registry中获取Metric的度量数据。
5）启动Reporter，每隔10秒的时间将会对Registry中的所有Metric进行一次report。
6）注释6处采用无限循环的方式模拟程序提供了不间断的服务。
7）注释7处调用数据上传方法，上传数据的大小是根据随机数获得的。
8）注释8处短暂休眠一段随机的时间。
9）对upload方法的每一次调用都会对tqs meter进行一次mark，也就意味着对其进行了一次计数。
10）对upload方法的每一次调用，都会通过volume meter对上传上来的字节流进行计数，以用于度量吞吐量。

```
-- Meters --------------------------------------------------
tqs
             count = 7
         mean rate = 20.75 events/minute
     1-minute rate = 13.62 events/minute
     5-minute rate = 12.38 events/minute
    15-minute rate = 12.13 events/minute
volume
             count = 4467
         mean rate = 13232.44 events/minute
     1-minute rate = 8433.26 events/minute
     5-minute rate = 7344.22 events/minute
    15-minute rate = 7123.20 events/minute


18-12-8 20:17:22 ===========================================

-- Meters ----------------------------------------------------
tqs
             count = 9
         mean rate = 17.85 events/minute
     1-minute rate = 13.37 events/minute
     5-minute rate = 12.37 events/minute
    15-minute rate = 12.13 events/minute
volume
             count = 5112
         mean rate = 10140.89 events/minute
     1-minute rate = 7554.72 events/minute
     5-minute rate = 7194.24 events/minute
    15-minute rate = 7075.20 events/minute


18-12-8 20:17:32 =======================================

-- Meters ---------------------------------------------------
tqs
             count = 10
         mean rate = 14.88 events/minute
     1-minute rate = 13.16 events/minute
     5-minute rate = 12.36 events/minute
    15-minute rate = 12.13 events/minute
volume
             count = 5189
         mean rate = 7723.02 events/minute
     1-minute rate = 6963.15 events/minute
     5-minute rate = 7082.89 events/minute
    15-minute rate = 7039.17 events/minute
```
通过Reporter的输出我们可以看到，upload方法调用了10次，通过EWMA模型（ExponentiallyWeighted Moving-Average，指数加权移动平均值的控制图）的统计可以得出，这些数据一分钟的平均速率将是14.88次，每分钟上传文件的平均字节数是7723.02字节。

#### Gauge
Gauge是最简单的Metric类型，如图7-3所示，它只返回一个Value值，比如，它可以用来查看某个关键队列在某个时刻的size，或者用来查看当前网站的在线人数等。
![[Pasted image 20240929115457.png|356]]
1. Simple Gauge详解
Simple Gauge就像它的名字所表明的那样，非常简单，仅会返回需要我们关注的值。比如，在block queue中，多线程同时对其进行pop及add操作，如果想要知道在某个时刻该队列的size是多少，则可以借助于Simple Gauge来进行实现。
```java
public interface Gauge<T> extends Metric {
    /**
     * Returns the metric's current value.
     *
     * @return the metric's current value
     */
    T getValue();
}
```
由上述代码段可知Gauge接口只有一个方法getValue()，因此我们可以将该接口称为FunctionalInterface。好了，接下来就来写一个获取queue size的metric应用程序。
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.Gauge;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

public class SimpleGaugeExample
{
    // 定义一个metric registry
    private static final MetricRegistry metricRegistry = new MetricRegistry();
    // 定义Console Reporter
    private static final ConsoleReporter reporter = ConsoleReporter.forRegistry(metricRegistry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();
    // 定义一个双向队列，这个队列是需要监控的队列
    private static final BlockingDeque<Long> queue = new LinkedBlockingDeque<>(1_000);

    public static void main(String[] args)
    {
        // 定义一个Simple Gauge，并且将其注册到registry中
        // Gauge的实现仅仅是返回queue的size，queue::size静态推导
        metricRegistry.register(MetricRegistry.name(SimpleGaugeExample.class, "queue-size"), (Gauge<Integer>) queue::size);

        reporter.start(1, TimeUnit.SECONDS);

        // 启动一个线程向队列中不断放入数据
        new Thread(() ->
        {
            for (; ; )
            {
                randomSleep();
                queue.add(System.nanoTime());
            }
        }).start();

        // 启动另外一个线程，从队列中不断地poll数据
        new Thread(() ->
        {
            for (; ; )
            {
                randomSleep();
                queue.poll();
            }
        }).start();
    }

   // 随机休眠
    private static void randomSleep()
    {
        try
        {
            TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(6));
        } catch (InterruptedException e)
        {
        }
    }
}
```
```

```

```log
-- Gauges ----------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 1


18-12-8 21:30:45 =======================

-- Gauges ----------------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 3


18-12-8 21:30:46 ==========================

-- Gauges ------------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 3


18-12-8 21:30:47 =========================

-- Gauges ---------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 2


18-12-8 21:30:48 ======================

-- Gauges -------------------------------
com.wangwenjun.concurrent.metrics.metric.SimpleGaugeExample.queue-size
             value = 2
```
通过输出信息，可以看到queue size的变化。通过这个度量数据，我们很容易就能发现生产者线程和消费者线程的处理速度，以及队列出现的积压情况，这对我们分析工作线程的运行性能非常重要。

2. JMX Attribute Gauge详解
除了在应用程序中可以定义很多符合JMX标准的MBean之外，JDK还为我们提供了非常多的MBean（如图7-4所示）​，用于诊断JVM的一些运行指标数据。如果想要获取JVM的MBean，则需要借助于jconsole、jvisualvm、jprofiler这样的工具；如果想要远程查看，那么还必须打开JMX服务端口。
```java
-Djava.rmi.server.hostname=192.168.2.142
-Dcom.sun.management.jmxremote.port=12345
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
```
![[Pasted image 20240929115932.png]]
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.JmxAttributeGauge;
import com.codahale.metrics.MetricRegistry;

import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import java.util.concurrent.TimeUnit;

public class JmxAttributeGaugeExample
{

    // 定义metric registry
    private final static MetricRegistry registry = new MetricRegistry();
    // 构造ConsoleReporter
    private final static ConsoleReporter reporter = ConsoleReporter
            .forRegistry(registry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();

    public static void main(String[] args)
            throws MalformedObjectNameException, InterruptedException
    {
        // 启动Reporter，每隔10秒的时间输出一次数据
        reporter.start(10, TimeUnit.SECONDS);

        // 注册JmxAttributeGauge，主要输出堆内存的使用情况
        registry.register(MetricRegistry.name(JmxAttributeGaugeExample.class, "Heap                            Memory"), new JmxAttributeGauge(new ObjectName("java.                            lang:type=Memory"), "HeapMemoryUsage"
        ));

        // 注册JmxAttributeGauge，主要输出非堆内存的使用情况
        registry.register(MetricRegistry.name(JmxAttributeGaugeExample.class, "NonHeap                            MemoryUsage"), new JmxAttributeGauge(new ObjectName("java.                            lang:type=Memory"), "NonHeapMemoryUsage"
        ));

        // 让主线程join，目的是不让程序退出
        Thread.currentThread().join();
    }
}
```

3. Ratio Gauge详解
Ratio Gauge可用于创建两个数字之间的某种比率，比如业务受理的成功率或失败率等。通常，我们在处理订单的时候，由于用户的原因可能会进行取消订单的操作，中断整个订单执行的流程。对于这样的数据统计，Ratio Gauge将会是一个非常好的选择
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.Meter;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.RatioGauge;

import java.util.concurrent.TimeUnit;

import static java.util.concurrent.ThreadLocalRandom.current;

public class RatioGaugeExample
{
    // 定义Metric Registry
    private final static MetricRegistry register = new MetricRegistry();
    // 定义Reporter
    private final static ConsoleReporter reporter = ConsoleReporter.            forRegistry(register)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();

    // 定义两个Metric
    private final static Meter totalMeter = new Meter();
    private final static Meter successMeter = new Meter();

    public static void main(String[] args)
    {
        // 启动Reporter
        reporter.start(10, TimeUnit.SECONDS);
        // 注册Ratio Gauge
        register.gauge("success-rate", () -> new RatioGauge()
        {
            @Override
            protected Ratio getRatio()
            {
                // ratio值等于successMeter和totalMeter
                return Ratio.of(successMeter.getCount(), totalMeter.getCount());
            }
        });
        // 无限循环，模拟程序持续服务
        for (; ; )
        {
            // 短暂休眠
            shortSleep();
            // 受理业务
            business();
        }
    }

    private static void business()
    {
        // 不论正确与否，total都会自增
        // total inc
        totalMeter.mark();
        try
        {
            // 随机数有可能会是0，因此这个操作可能会出现错误
            int x = 10 / current().nextInt(6);
            // success inc
            // 成功受理之后，success会自增
            successMeter.mark();

        } catch (Exception e)
        {
            System.out.println("ERROR");
        }
    }

    private static void shortSleep()
    {
        try
        {
            TimeUnit.SECONDS.sleep(current().nextInt(6));
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
}
```

```log
ERROR
18-12-8 23:19:52 =======================

-- Gauges ------------------------------
success-rate
             value = 0.6666666666666666


ERROR
18-12-8 23:20:02 ========================

-- Gauges ---------------------------------
success-rate
             value = 0.75


18-12-8 23:20:12 =========================

-- Gauges ---------------------------
success-rate
             value = 0.8333333333333334


ERROR
ERROR
ERROR
18-12-8 23:20:22 =========================

-- Gauges --------------------------------
success-rate
             value = 0.7222222222222222
```
每隔10秒的时间，业务的成功率度量信息将会输出到控制台上，除了可以看到成功率之外，我们还可以看到ERROR字样（分母为零时会出现）​。当然，totalMeter和successMeter完全可以使用AtomicLong替代，这没有任何问题，目的都主要是对数值进行存储。

4. Cached Gauge详解
有时，我们想要获取的Gauge value对实时性的要求并没有那么高，比如我们想要从数据库中获取用户的状态，或者计算某个队列的size，这样我们就没有必要每次都计算它的真实Value，而是将计算结果暂时缓存一段时间，等设置的时间过期之后再重新获取。我们来看一下示例程序的代码。
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.CachedGauge;
import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.TimeUnit;

public class CachedGaugeExample
{
    // 定义Metric Registry
    private final static MetricRegistry registry = new MetricRegistry();
    // 定义Reporter
    private final static ConsoleReporter reporter = ConsoleReporter                .forRegistry(registry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();

    public static void main(String[] args) throws InterruptedException
    {
        // 启动Reporter
        reporter.start(10, TimeUnit.SECONDS);
        // 定义Metric，并且注册到Metric Registry中
        registry.gauge("cached-db-size",                              () -> new CachedGauge<Long>(30, TimeUnit.SECONDS)
        {
            @Override
            protected Long loadValue()
            {
                // 从数据库中查询数据
                return queryFromDB();
            }
        });
        Thread.currentThread().join();
    }

    private static long queryFromDB()
    {
        System.out.println("====queryFromDB=====");
        return System.currentTimeMillis();
    }
}
```

5. Derivative Gauge详解
Derivative Gauge允许从某个Gauge value中获取特定的属性和值，比如，我们将Cache的Stats作为一个Metric，Stats中包含了非常多的属性，但是我们只需要其中的一两个，比如Cache未命中率、Cache加载异常统计等，此时我们就可以借助Derivative Gauge来派生这样的功能。
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.DerivativeGauge;
import com.codahale.metrics.Gauge;
import com.codahale.metrics.MetricRegistry;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.CacheStats;
import com.google.common.cache.LoadingCache;

import java.util.concurrent.TimeUnit;

public class DerivativeGaugeExample
{
    //定义Cache
    private final static LoadingCache<String, String> cache = CacheBuilder
            .newBuilder().maximumSize(10)
            .expireAfterAccess(5, TimeUnit.SECONDS)
            //开启Cache Stats统计功能
            .recordStats()
            .build(new CacheLoader<String, String>()
            {
                @Override
                public String load(String key) throws Exception
                {
                    return key.toUpperCase();
                }
            });
    //定义Metric Registry
    private final static MetricRegistry registry = new MetricRegistry();
    //定义Reporter
    private final static ConsoleReporter reporter = ConsoleReporter.                forRegistry(registry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();

    public static void main(String[] args) throws InterruptedException
    {
        //启动Reporter
        reporter.start(10, TimeUnit.SECONDS);
        //注册一个Gauge Metric，value是cache的stats
        Gauge<CacheStats> cacheGauge = registry.gauge("cache-stats",                                                            () -> cache::stats);
        //通过cacheGauge派生missCount metric，并且注册到Registry
        registry.register("missCount", new DerivativeGauge<CacheStats, Long>(cacheGauge)
        {
            @Override
            protected Long transform(CacheStats stats)
            {
                return stats.missCount();
            }
        });

        //通过cacheGauge派生loadExceptionCountmetric，并且注册到Registry
        registry.register("loadExceptionCount",                                 new DerivativeGauge<CacheStats, Long>(cacheGauge)
        {
            @Override
            protected Long transform(CacheStats stats)
            {
                return stats.loadExceptionCount();
            }
        });

        while (true)
        {
            business();
            TimeUnit.SECONDS.sleep(1);
        }
    }

    private static void business()
    {
        cache.getUnchecked("alex");
    }
}
```
关于Google Guava请读者查阅官方文档自行学习，文档地址为https://github.com/google/guava。

#### Counter
我们使用一个简单的Gauge获取了queue的当前size作为一个Metric，这种方式看起来能够正常运行，但是调用相关API的方式获取value会影响到其他线程使用queue本身的性能，这种度量方式也会对应用程序带来性能上的侵入损耗。
Counter Metric提供了一个64位数字的递增和递减的解决方案（如图7-5所示）​，可以帮我们解决在度量的过程中性能侵入的问题。
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.Counter;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.TimeUnit;

import static java.util.concurrent.ThreadLocalRandom.current;

public class CounterExample
{
    // 定义Metric Registry
    private static final MetricRegistry metricRegistry = new MetricRegistry();
    // 定义Reporter
    private static final ConsoleReporter reporter = ConsoleReporter                .forRegistry(metricRegistry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();
    // 定义Blocking双向队列，size为1000
    private static final BlockingDeque<Long> queue = new                LinkedBlockingDeque<>(1_000);

    public static void main(String[] args)
    {
        reporter.start(10, TimeUnit.SECONDS);
        // 定义并注册Counter Metric到Registry中
        Counter counter = metricRegistry.counter("queue-count", Counter::new);

        // 定义一个线程，用于将元素添加到queue中，但是在增加了元素之后，调用counter的递增方法
          new Thread(() ->
        {
            for (; ; )
            {
                randomSleep();
                queue.add(System.nanoTime());
                counter.inc();
            }
        }).start();

        // 定义另外一个线程，从queue中poll元素，当元素被poll出后，调用counter的递减方法
          new Thread(() ->
        {
            for (; ; )
            {
                randomSleep();
                if (queue.poll() != null)
                    counter.dec();
            }
        }).start();
    }

    private static void randomSleep()
    {
        try
        {
            TimeUnit.MILLISECONDS.sleep(current().nextInt(500));
        } catch (InterruptedException e)
        {
        }
    }
}
```
我们不再调用queue的size()方法作为度量值的获取方法，因为这种方式存在对被度量资源的侵入性，Counter Metric经过改造之后同样可以完成我们想要的效果。

#### Histogram
直方图（Histogram）又称质量分布图，是一种统计报告图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况
![[Pasted image 20240929120930.png]]
直方图是数值数据分布的精确图形表示，这是一个对连续变量（定量变量）的概率分布的估计，并且由卡尔·皮尔逊（Karl Pearson）首先引入，它是一种条形图。构建直方图的步骤是，首先对值的范围进行分段，即将整个值的范围分成一系列的间隔，然后计算每个间隔中有多少个值。这些值通常被指定为连续的、不重叠的变量间隔。间隔必须相邻，并且通常是（但不是必需的）相等的大小。
```java
package com.wangwenjun.concurrent.metrics.metric;

import com.codahale.metrics.ConsoleReporter;
import com.codahale.metrics.Histogram;
import com.codahale.metrics.MetricRegistry;

import java.util.concurrent.TimeUnit;

import static java.util.concurrent.ThreadLocalRandom.current;

public class HistogramExample
{
    // 定义Metric Registry
    private final static MetricRegistry registry = new MetricRegistry();
    // 构造Reporter
    private final static ConsoleReporter reporter = ConsoleReporter                .forRegistry(registry)
            .convertRatesTo(TimeUnit.SECONDS)
            .convertDurationsTo(TimeUnit.SECONDS)
            .build();
    // 构造Histogram Metric并且将其注册到Registry中
    private final static Histogram histogram = registry.histogram("search-result");

    public static void main(String[] args)
    {
        // 启动Reporter
        reporter.start(10, TimeUnit.SECONDS);

        // 无限循环，模拟持续服务
        while (true)
        {
            // 根据用户提交的关键字进行搜索
            doSearch();
            randomSleep();
        }
    }

    private static void doSearch()
    {
        // 搜索结果从随机数获得0～9之间的结果条目
        histogram.update(current().nextInt(10));
    }

    private static void randomSleep()
    {
        try
        {
            TimeUnit.SECONDS.sleep(current().nextInt(5));
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
}
```