### AtomicInteger详解

#### 性能测试对比
任何新工具的出现，都是为了解决某个具体问题而诞生的，否则就没有存在的必要了，原子类型就是一种无锁的、线程安全的、使用基本数据类型和引用类型的很好的解决方案。
```java
package com.frank.concurrent.juc.automic;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.profile.StackProfiler;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;
import org.openjdk.jmh.runner.options.TimeValue;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

// 度量批次为10次
@Measurement(iterations = 10)
// 预热批次为10次
@Warmup(iterations = 10)
// 采用平均响应时间作为度量方式
@BenchmarkMode(Mode.AverageTime)
// 时间单位为微秒
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public class SynchronizedVsLockVsAtomicInteger {
    @State(Scope.Group)
    public static class IntMonitor {
        private int x;
        private final Lock lock = new ReentrantLock();

        // 使用显式锁Lock进行共享资源同步
        public void lockInc() {
            lock.lock();
            try {
                x++;
            } finally {
                lock.unlock();
            }
        }

        // 使用synchronized关键字进行共享资源同步
        public void synInc() {
            synchronized (this) {
                x++;
            }
        }
    }

    // 直接采用AtomicInteger
    @State(Scope.Group)
    public static class AtomicIntegerMonitor {
        private AtomicInteger x = new AtomicInteger();

        public void inc() {
            x.incrementAndGet();
        }
    }

    // 基准测试方法
    @GroupThreads(10)
    @Group("sync")
    @Benchmark
    public void syncInc(IntMonitor monitor) {
        monitor.synInc();
    }

    // 基准测试方法
    @GroupThreads(10)
    @Group("lock")
    @Benchmark
    public void lockInc(IntMonitor monitor) {
        monitor.lockInc();
    }

    // 基准测试方法
    @GroupThreads(10)
    @Group("atomic")
    @Benchmark
    public void atomicIntegerInc(AtomicIntegerMonitor monitor) {
        monitor.inc();
    }

    public static void main(String[] args) throws RunnerException {
        Options opts = new OptionsBuilder()
                .include(SynchronizedVsLockVsAtomicInteger.class.getSimpleName())
                .forks(1)
                .timeout(TimeValue.seconds(10))
                .addProfiler(StackProfiler.class)
                .build();
        new Runner(opts).run();
    }
}
```
```
Benchmark                                       Mode  Cnt  Score   Error  Units
SynchronizedVsLockVsAtomicInteger.atomic        avgt   10  0.317 ± 0.072  us/op
SynchronizedVsLockVsAtomicInteger.atomic:stack  avgt         NaN            ---
SynchronizedVsLockVsAtomicInteger.lock          avgt   10  0.382 ± 0.012  us/op
SynchronizedVsLockVsAtomicInteger.lock:stack    avgt         NaN            ---
SynchronizedVsLockVsAtomicInteger.sync          avgt   10  0.512 ± 0.029  us/op
SynchronizedVsLockVsAtomicInteger.sync:stack    avgt         NaN            ---
```

#### AtomicInteger的基本用法
与int的引用类型Integer继承Number类一样，AtomicInteger也是Number类的一个子类，除此之外，AtomicInteger还提供了很多原子性的操作方法
##### 1. AtomicInteger的创建
▪ public AtomicInteger()：创建AtomicInteger的初始值为0。
▪ public AtomicInteger(int initialValue)：创建AtomicInteger并且指定初始值，无参的AtomicInteger对象创建等价于AtomicInteger(0)。

##### 2. AtomicInteger的Incremental操作
x++或者x=x+1这样的操作是非原子性的，要想使其具备原子性的特性，我们可以借助AtomicInteger中提供的原子性Incremental的操作方法。
▪ int getAndIncrement()：返回当前int类型的value值，然后对value进行自增运算（在2.1.3节中我们将学习到该方法的内部原理）​，该操作方法能够确保对value的原子性增量操作。
```java
public static void main(String[] args)
{
    final AtomicInteger ai = new AtomicInteger(5);
    // 返回AtomicInteger的int值，然后自增（在多线程的情况下，下面的断言未必正确）
    assert ai.getAndIncrement() == 5;
    // 获取自增后的结果（在多线程的情况下，下面的断言未必正确）
    assert ai.get() == 6;
}
```
▪ int incrementAndGet()：直接返回自增后的结果

##### 3. AtomicInteger的Decremental操作
x--或者x=x-1这样的自减操作同样也是非原子性的，要想使其具备原子性的特性，我们可以借助AtomicInteger中提供的原子性Decremental的操作方法。
▪ int getAndDecrement()：返回当前int类型的value值，
```java
AtomicInteger ai = new AtomicInteger(5);
assert ai.getAndDecrement() == 5;
assert ai.get() == 4;
```

##### 4. 原子性地更新value值
boolean compareAndSet(int expect, intupdate)：原子性地更新AtomicInteger的值，其中expect代表当前的AtomicInteger数值，update则是需要设置的新值，该方法会返回一个boolean的结果：当expect和AtomicInteger的当前值不相等时，修改会失败，返回值为false；若修改成功则会返回true。
```java
// 定义一个AtomicInteger类型的对象ai并且指定初值为10
AtomicInteger ai = new AtomicInteger(10);
// 调用compareAndSet方法，expect的值为100，修改肯定会失败
assert !ai.compareAndSet(100, 12);
// 修改并未成功，因此新值不等于12
assert ai.get() != 12;
// 执行了compareAndSet更新方法之后，ai的返回值依然为10，因为修改失败
assert ai.get() == 10;

// 调用compareAndSet方法，expect的值为10，修改成功（多线程情况下并不能担保百分之百成功，// 关于这一点，在2.1.3节中会为大家讲解）
assert ai.compareAndSet(10, 12);
// 断言成功
assert ai.get() == 12;
```


boolean weakCompareAndSet(int expect, intupdate)：目前版本JDK中的该方法与compareAndSet完全一样
```java
// compareAndSet方法源码
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
// weakCompareAndSet方法源码
public final boolean weakCompareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```

#### AtomicInteger内幕
```java
// Unsafe是由C++实现的，其内部存在着大量的汇编 CPU指令等代码，JDK实现的
// Lock Free几乎完全依赖于该类
private static final Unsafe unsafe = Unsafe.getUnsafe();
// valueOffset将用于存放value的内存地址偏移量
private static final long valueOffset;
static {
    try {
        // 获取value的内存地址偏移量
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField("value"));
    } catch (Exception ex) { throw new Error(ex); }
}
// 我们不止一次地说过，在AtomicInteger的内部有一个volatile修饰的int类型成员属性value private volatile int value;
```

1. compareAndSwapInt源码分析——CAS算法
CAS包含3个操作数：内存值V、旧的预期值A、要修改的新值B。当且仅当预期值A与内存值V相等时，将内存值V修改为B，否则什么都不需要做。
compareAndSwapInt方法是一个native方法，提供了CAS（Compare And Swap）算法的实现，AtomicInteger类中的原子性方法几乎都借助于该方法实现。




