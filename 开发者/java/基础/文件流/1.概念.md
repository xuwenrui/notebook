#### java有那些文件流
##### 字节流

字节流主要用于处理二进制数据，如图片、音频、视频文件等。

1. **InputStream** - 所有字节输入流的基类。
    - **FileInputStream** - 从文件系统中的某个文件读取字节。
2. **OutputStream** - 所有字节输出流的基类。
    - **FileOutputStream** - 向文件系统中的文件写入字节。
    - **BufferedOutputStream** - 带缓冲区的输出流，提高了对文件的写入效率。
    - **DataOutputStream** - 允许写入基本类型数据的输出流。

##### 字符流
### 对象序列化流

用于将Java对象转换为字节流，或者从字节流恢复Java对象。

- **ObjectInputStream** - 从字节流中读取对象。
- **ObjectOutputStream** - 将对象写入字节流。

##### 高级/特殊用途流

除了基本的文件操作外，Java还提供了许多高级或具有特殊用途的流类，比如用于处理压缩文件的`GZIPOutputStream`、`GZIPInputStream`，以及支持随机访问文件的`RandomAccessFile`等。

##### response.getOutputStream()
1. **即时写入与缓冲**：当你通过`ServletOutputStream`写数据时，数据并不会立即发送到客户端，而是通常先写入到服务器的缓冲区中。这个缓冲区的大小是可以配置的，而且现代服务器为了效率和减少网络IO次数，倾向于使用一定大小的缓冲。只有当缓冲区满或者你显式地执行`flush()`操作时，数据才会从缓冲区被推送到客户端。因此，在数据被完全发送出去之前，它确实会占用一部分服务器的内存。
    
2. **大对象和流式传输**：对于大型数据（如大文件下载），如果直接将整个文件加载到内存中再通过`OutputStream`写出，确实会导致内存溢出。为了避免这个问题，应该采用流式传输的方式，即读取数据源（如文件）的同时立即通过输出流写入并发送，同时可能需要手动调用`flush()`来确保数据被及时推送，减少内存占用。这种方式下，数据不必全部预先加载到内存中。
    
3. **内存管理**：服务器和容器也会有相应的机制来管理这些缓冲，比如在数据被发送后，缓冲区可以被重用或释放，以避免长时间占用大量内存。