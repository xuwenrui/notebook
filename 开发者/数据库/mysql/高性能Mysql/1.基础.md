### ACID
ACID代表原子性(atomicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)。一个确保数据安全的事务处理系统，必须满足这些密切相关的标准。
#### 原子性(atomicity)
一个事务必须被视为一个不可分割的工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

#### 一致性(consistency)
数据库总是从一个一致性状态转换到下一个一致性状态。

#### 隔离性(isolation)
通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的，这就是隔离性带来的结果。
#### 持久性(durability)
一旦提交，事务所做的修改就会被永久保存到数据库中。此时即使系统崩溃，数据也不会丢失。


### 4种隔离级别
#### READ UNCOMMITTED（未提交读）
在READ UNCOMMITTED级别，在事务中可以查看其他事务中还没有提交的修改。这个隔离级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他级别好太多，却缺乏其他级别的很多好处，除非有非常必要的理由，在实际应用中一般很少使用。
读取未提交的数据，也称为脏读(dirty read)。

#### READ COMMITTED（提交读）
大多数数据库系统的默认隔离级别是READCOMMITTED（但MySQL不是）​。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务可以看到其他事务在它开始之后提交的修改，但在该事务提交之前，其所做的任何修改对其他事务都是不可见的。这个级别仍然允许不可重复读(nonrepeatable read)，这意 味着同一事务中两次执行相同语句，可能会看到不同的数据结果。

#### REPEATABLE READ（可重复读）
REPEATABLE READ解决了READ COMMITTED级别的不可重复读问题，保证了在同一个事务中多次读取相同行数据的结果是一样的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读(phantom read)的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行(phantom row)。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC，Multiversion ConcurrencyControl)解决了幻读的问题。本章稍后会对此做进一步讨论。
