### ACID
ACID代表原子性(atomicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)。一个确保数据安全的事务处理系统，必须满足这些密切相关的标准。
#### 原子性(atomicity)
一个事务必须被视为一个不可分割的工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

#### 一致性(consistency)
数据库总是从一个一致性状态转换到下一个一致性状态。

#### 隔离性(isolation)
通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的，这就是隔离性带来的结果。
#### 持久性(durability)
一旦提交，事务所做的修改就会被永久保存到数据库中。此时即使系统崩溃，数据也不会丢失。


### 4种隔离级别
#### READ UNCOMMITTED（未提交读）
在READ UNCOMMITTED级别，在事务中可以查看其他事务中还没有提交的修改。这个隔离级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他级别好太多，却缺乏其他级别的很多好处，除非有非常必要的理由，在实际应用中一般很少使用。
读取未提交的数据，也称为脏读(dirty read)。

#### READ COMMITTED（提交读）
大多数数据库系统的默认隔离级别是READCOMMITTED（<font color="#953734">但MySQL不是</font>）​。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务可以看到其他事务在它开始之后提交的修改，但在该事务提交之前，其所做的任何修改对其他事务都是不可见的。这个级别仍然允许不可重复读(nonrepeatable read)，这意 味着同一事务中两次执行相同语句，可能会看到不同的数据结果。

#### REPEATABLE READ（可重复读）
REPEATABLE READ解决了READ COMMITTED级别的不可重复读问题，保证了在同一个事务中多次读取相同行数据的结果是一样的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读(phantom read)的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行(phantom row)。InnoDB和XtraDB存储引擎通过多版本并发控制(MVCC，Multiversion ConcurrencyControl)解决了幻读的问题。本章稍后会对此做进一步讨论。

<font color="#953734">REPEATABLE READ 是 MySQL 的默认隔离级别。</font>
###### 查看全局变量:
mysql5.x: SELECT @@global.tx_isolation;
mysql8.x: SELECT @@global.transaction_isolation;
###### 查看会话变量
SELECT @@session.tx_isolation;
SELECT @@tx_isolation;

#### SERIALIZABLE（可串行化）
 SERIALIZABLE是最高的隔离级别。该级别通过强制事务按序执行，使不同事务之间不可能产生冲突，从而解决了前面说的幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，除非需要严格确保数据安全且可以接受并发性能下降的结果。

### 死锁
死锁是指两个或多个事务相互持有和请求相同资源上的锁，产生了循环依赖。

例如，设想运行下面两个针对主键为(stock_id，date)的StockPrice表的事务：
事务1
![[Pasted image 20240831101628.png]]
事务2
![[Pasted image 20240831101705.png]]
每个事务都开始执行第一个查询，在处理过程中会更新一行数据，同时在主键索引和其他唯一索引中将该行锁定。然后，每个事务将在第二个查询中尝试更新第二行数据，却发现该行已经被锁定。这两个事务将永远等待对方完成，除非有其他因素介入解除死锁。

###### ji