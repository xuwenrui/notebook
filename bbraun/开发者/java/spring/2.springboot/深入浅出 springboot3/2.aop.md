#### 约定

![[Pasted image 20240826185919.png]]

#### Invocation
```java
package com.learn.chapter4.invoke;
/**** imports ****/
　
public class Invocation {
   private Object[] params; // 参数
   private Method method; // 方法
   private Object target; // 目标对象
   private Interceptor interceptor; // 拦截器
　
   public Invocation(Object target,
         Method method, Object[] params, Interceptor interceptor) {
      this.target = target;
      this.method = method;
      this.params = params;
      this.interceptor = interceptor;
   }
　
   // 反射方法
   public Object proceed() throws InvocationTargetException, IllegalAccessException {
      Object retObj = null; // 返回结果
      boolean exceptionFlag = false; // 异常标志位
      // 调用拦截器的before()方法
      this.interceptor.before();
      try {
         // 使用反射调用原有方法，并保存返回值
         retObj = method.invoke(target, params);
      } catch (Exception ex) {
         // 设置异常标志位
         exceptionFlag = true;
      }
      if (exceptionFlag) { // 发生异常则运行拦截器的afterThrowing()方法
         this.interceptor.afterThrowing();
      } else { // 未发生异常则运行拦截器的afterReturning()方法
         this.interceptor.afterReturning();
      }
      // 无论发生异常与否，都会运行的拦截器after()方法
      this.interceptor.after();
      return retObj;
   }
　
   /**** setters and getters ****/
}
```

##### 测试代理方法
```java
package com.learn.chapter4.main;
/**** imports ****/
public class AopTest {
　
   public static void main(String[] args) {
      testProxy();
   }
   public static void testProxy() {
      // 目标对象
      var helloService = new HelloServiceImpl();
      // 获取代理对象，绑定流程
      var proxy = (HelloService) ProxyBean.getProxy(
             helloService, new MyInterceptor());
      // 调用方法，该方法将被织入约定的流程中
      proxy.sayHello("张三");
      System.out.println("###############测试异常###############");
      // 调用方法，测试异常情况
      proxy.sayHello(null);
   }
}
```

#### ProxyBean的实现
Spring Boot一般会采用两种动态代理——JDK和CGLIB，在Spring Boot应用中，默认使用的是CGLIB动态代理
```java
// 创建增强者
var enhancer = new Enhancer();
// 设置目标对象，target为目标对象
enhancer.setSuperclass(target.getClass());
// 设置代理对象可以下挂到哪些接口下
enhancer.setInterfaces(target.getClass().getInterfaces());
// 指定代理对象
// methodInterceptor对象实现了接口MethodInterceptor定义的intercept()方法
enhancer.setCallback(methodInterceptor);
// 创建动态代理对象
var proxy = enhancer.create();
```

##### MethodInterceptor接口定义的intercept()方法
```java
/**
* 代理对象逻辑
* @param proxy 代理对象
* @param method 拦截器的方法
* @param args 方法参数
* @param mproxy 方法代理
* @return 返回目标方法和对象
*/
@Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy mproxy)
```

##### 实现类ProxyBean
```java
package com.learn.chapter4.proxy;
　
/**** imports ****/
public class ProxyBean implements MethodInterceptor {
   // 拦截器
   private Interceptor interceptor = null;
   // 目标对象
   private Object target = null;
   /**
    * 生成代理对象
    * @param target 目标对象
    * @param interceptor 拦截器
    * @return 代理对象
    */
   public static Object getProxy(Object target, Interceptor interceptor) {
      var proxyBean = new ProxyBean();
      // 创建增强者
      var enhancer = new Enhancer();
      // 设置代理的类
      enhancer.setSuperclass(target.getClass());
      // 设置代理对象可以下挂到哪些接口下
      enhancer.setInterfaces(target.getClass().getInterfaces());
      // 保存目标对象
      proxyBean.target = target;
      // 保存拦截器
      proxyBean.interceptor = interceptor;
      // 设置代理对象为proxyBean，运行时会回调代理对象的intercept()方法
      enhancer.setCallback(proxyBean); // ①
      // 创建动态代理对象
      var proxy = enhancer.create();
      return proxy;
   }
   /**
    * 代理对象逻辑
    * @param proxy 代理对象
    * @param method 拦截器的方法
    * @param args 方法参数
    * @param mproxy 方法代理
    * @return 返回目标方法和对象
    */
   @Override
   public Object intercept(Object proxy, Method method, Object[] args, MethodProxy mproxy)
          throws Throwable {
      // 回调对象
      Invocation invocation =
            new Invocation(this.target, method, args, this.interceptor);
      Object result = null;
      if (this.interceptor.useAround()) { // 是否启用环绕通知
         result = this.interceptor.around(invocation);
      } else {
         result = invocation.proceed();
      }
      // 返回结果
      return result;
   }
　
}
```
这个ProxyBean实现了接口MethodInterceptor的intercept()方法。其中，getProxy()方法会通过增强者来绑定被代理类和可下挂的接口，并且在代码①处设置回调proxyBean对象的intercept()方法。
```java
// 目标对象
var helloService = new HelloServiceImpl();
// 获取代理对象，绑定流程
var proxy = (HelloService) ProxyBean.getProxy(helloService, new MyInterceptor());
```

#### AOP的知识
实际上Spring AOP也是一种约定流程的编程.

●连接点(join point)：并非所有地方都需要启用AOP，而连接点就是告诉AOP在哪里需要通过包装将方法织入流程。因为Spring只能支持方法，所以被拦截的往往就是指定的方法.
●切点(point cut)：有时候需要启用AOP的地方不是单个方法，而是多个类的不同方法。这时，可以通过正则式和指示器的规则来定义切点，让AOP根据切点的定义匹配多个需要AOP拦截的方法，将它们包装为成一个个连接点。
●通知(advice)：约定的流程中的方法，分为前置通知(before advice)、后置通知(after advice)、环绕通知(around advice)、返回通知(afterReturning advice)和异常通知(afterThrowing advice)，这些通知会根据约定织入流程中，需要弄明白它们在流程中的运行顺序和运行的条件。
●目标对象(target)：即被代理对象。例如，约定编程中的HelloServiceImpl实例就是目标对象，它被代理了。●引入(introduction)：指引入新的类（接口）和其方法，可以增强现有Bean的功能。
●织入(weaving)：它是一个通过动态代理技术，为目标对象生成代理对象，然后将与切点定义匹配的连接点拦





