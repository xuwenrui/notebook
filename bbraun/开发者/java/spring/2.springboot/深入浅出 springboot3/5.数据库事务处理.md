```
# 数据库连接URL
spring.datasource.url=jdbc:mysql://localhost:3306/chapter6
# 数据库用户名
spring.datasource.username=root
# 数据库密码
spring.datasource.password=123456
# 数据库连接驱动类，即便不配置，Spring Boot也会自动探测
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
　
# 使用默认的Hikari数据源
# 数据源最大连接数量，默认为10
spring.datasource.hikari.maximum-pool-size=50
# 最大连接生存期，默认为1800000 ms（也就是30 m）
spring.datasource.hikari.max-lifetime=1800000
# 最小空闲连接数，默认值为10
spring.datasource.hikari.minimum-idle=10
　
# 日志配置
logging.level.root=DEBUG
logging.level.org.springframework=DEBUG
logging.level.org.mybatis=DEBUG
```

#### JDBC的数据库事务
```java
package com.learn.chapter6.service.impl;
/**** imports ****/
@Service
public class JdbcServiceImpl implements JdbcService {
   @Autowired
   private DataSource dataSource;
　
   @Override
   public int insertUser(String userName, String note) {
      Connection conn = null;
      var result = 0;
      try {
         // 获取数据库连接
         conn = dataSource.getConnection();
         // 启用事务
         conn.setAutoCommit(false);
         // 设置隔离级别
         conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
         var sql = "insert into t_user(user_name, note ) values(?, ?)";
         // 运行SQL语句
         var ps = conn.prepareStatement(sql);
         ps.setString(1, userName);
         ps.setString(2, note);
         result = ps.executeUpdate();
         // 提交事务
         conn.commit();
      } catch (Exception e) {
         // 回滚事务
         if (conn != null) {
            try {
               conn.rollback();
            } catch (SQLException e1) {
               e1.printStackTrace();
            }
         }
         e.printStackTrace();
      } finally {
         // 关闭数据库连接
         try {
            if (conn != null && !conn.isClosed()) {
               conn.close();
            }
         } catch (SQLException e) {
            e.printStackTrace();
         }
      }
      return result;
   }
　
}
```
![[Pasted image 20240827081227.png]]

#### Spring声明式事务的使用

##### Spring声明式事务约定
![[Pasted image 20240827081406.png]]
```java
......
public class UserServiceImpl implements UserService {
　
   @Autowired
   private UserDao userDao = null;
   @Override
   @Transactional
   public int insertUser(User user) {
      return userDao.insertUser(user);
   }
   ......
}
```
##### 注解@Transactional的配置项
```java
package org.springframework.transaction.annotation;
　
/**** imports ****/
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
   // 同transactionManager
   @AliasFor("transactionManager")
   String value() default "";
　
   // 配置数据管理器的名称
   @AliasFor("value")
   String transactionManager() default "";
   // 配置事务的标签
   String[] label() default {};
　
   // 配置数据库的隔离级别
   Isolation isolation() default Isolation.DEFAULT;
　
   // 配置方法的传播行为
   Propagation propagation() default Propagation.REQUIRED;
   // 设置事务的超时时间
   int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;
   // 设置事务超时时间字符串
   String timeoutString() default "";
　
   // 设置事务是否只读
   boolean readOnly() default false;
   // 设置只在什么异常下回滚事务
   Class<? extends Throwable>[] rollbackFor() default {};
   // 设置只在什么异常名称下回滚事务
   String[] rollbackForClassName() default {};
   // 设置在什么异常下不回滚事务
   Class<? extends Throwable>[] noRollbackFor() default {};
　
   // 设置在什么异常名称下不回滚事务
   String[] noRollbackForClassName() default {};
　
}
```
timeout表示事务的超时时间，单位为s；readOnly属性定义事务是不是只读事务。rollbackFor()、rollbackForClassName()、noRollbackFor()和noRollbackForClassName()用于指定异常，在运行业务方法时，可能发生异常，通过设置这些属性，可以指定在哪些异常情况下依旧提交事务
#### Spring事务管理器
##### PlatformTransactionManager源码分析
```java
package org.springframework.transaction;
　
import org.springframework.lang.Nullable;
　
public interface PlatformTransactionManager extends TransactionManager {
　
   // 获取事务，返回事务状态
   TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
         throws TransactionException;
　
   // 提交事务
   void commit(TransactionStatus status) throws TransactionException;
　
   // 回滚事务
   void rollback(TransactionStatus status) throws TransactionException;
　
} 
```