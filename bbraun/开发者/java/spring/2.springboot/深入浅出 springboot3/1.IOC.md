#### 概念
每个需要管理的对象称为Spring Bean（简称Bean）​，而Spring管理这些Bean的容器称为Spring IoC容器（简称IoC容器）​。
IoC容器需要具备两个基本的功能：
- 通过描述管理Bean，包括定义、发布、装配和销毁Bean；
- 通过描述完成Bean之间的依赖关系。


####  IoC容器简介
IoC容器是一个管理Bean的容器，在Spring的定义中，所有IoC容器都需要实现接口BeanFactory，它是一个顶级容器接口
```java
package org.springframework.beans.factory;
　
/**** imports ****/
public interface BeanFactory {
    // 前缀
   String FACTORY_BEAN_PREFIX = "&";
　
   // 多个getBean()方法
   Object getBean(String name) throws BeansException;
　
   <T> T getBean(String name, Class<T> requiredType) throws BeansException;
　
   <T> T getBean(Class<T> requiredType) throws BeansException;
　
   Object getBean(String name, Object... args) throws BeansException;
　
   <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;
　
   // 两个获取Bean的提供器
   <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
　
   <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);
　
   // 是否包含Bean
   boolean containsBean(String name);
　
   // Bean是否为单例
   boolean isSingleton(String name) throws NoSuchBeanDefinitionException;
　
   // Bean是否为原型
   boolean isPrototype(String name) throws NoSuchBeanDefinitionException;
　
   // 是否类型匹配
   boolean isTypeMatch(String name, ResolvableType typeToMatch)
      throws NoSuchBeanDefinitionException;
　
   boolean isTypeMatch(String name, Class<?> typeToMatch)
      throws NoSuchBeanDefinitionException;
　
   // 获取Bean的类型
   Class<?> getType(String name) throws NoSuchBeanDefinitionException;
　
   Class<?> getType(String name, boolean allowFactoryBeanInit)
      throws NoSuchBeanDefinitionException;
　
   // 获取Bean的别名
   String[] getAliases(String name);
}
```

●getBean()：这是IoC容器最重要的方法之一，它的作用是从IoC容器中获取Bean。从多个getBean()方法中可以看到，有按名称(by name)获取Bean的，也有按类型(by type)获取Bean的，这就意味着在IoC容器中，允许我们按名称或者类型获取Bean
●isSingleton()：判断Bean是否在IoC容器中为单例。这里需要记住的是，在IoC容器中， Bean默认都是以单例存在的，也就是使用getBean()方法根据名称或者类型获取的对象，在默认的情况下，返回的都是同一个对象。
●isPrototype()：与isSingleton()方法是相反的，如果它返回的是true，那么当我们使用getBean()方法获取Bean的时候，IoC容器就会创建一个新的Bean返回给调用者
![[Pasted image 20240826095755.png]]

ApplicationContext接口通过扩展上级接口，进而扩展了BeanFactory接口，但是在BeanFactory的基础上，扩展了消息国际化接口(MessageSource)、环境可配置化接口(EnvironmentCapable)、应用事件发布接口(ApplicationEventPublisher)和资源模式解析器接口(ResourcePatternResolver)，所以ApplicationContext的功能会更为强大。


#### AnnotationConfigApplicationContext
Spring Boot主要通过注解来将Bean装配到IoC容器中，为了贴近Spring Boot的需要，这里不再介绍与XML相关的IoC容器，而主要介绍一个基于注解的IoC容器——AnnotationConfigApplicationContext。
```java
package com.learn.chapter3.config;
/**** imports ****/
// 标注为Java配置类
@Configuration
public class AppConfig {
   // @Bean表示将initUser()方法返回的对象装配到IoC容器中，该方法的属性name表示Bean的名称
   @Bean(name = "user")
   public User initUser() {
      var user = new User();
      user.setId(1L);
      user.setUserName("user_name_1");
      user.setNote("note_1");
      return user;
   }
}
```

```java
package com.learn.chapter3.main;
/**** imports ****/
public class IoCTest {
　
   public static void main(String[] args) {
      // 使用配置文件AppConfig.java创建IoC容器
      var ctx = new AnnotationConfigApplicationContext(AppConfig.class);
      try {
         // 通过getBean()方法获取Bean
         var user = ctx.getBean(User.class);
         System.out.println(user.getUserName());
      } finally {
         // 关闭IoC容器
         ctx.close();
      }
   }
}
```


#### 通过扫描装配你的Bean
●@Component：标注扫描哪些类，创建Bean并装配到IoC容器中。
●@ComponentScan：配置采用何种策略扫描并装配Bean。
```java
package com.learn.chapter3.config;
/**** imports ****/
　
// 标注为Java配置类
@Configuration
// 配置扫描策略
@ComponentScan
public class AppConfig {
}
```


#####  @ComponentScan源码
```java
package org.springframework.context.annotation;
　
/**imports**/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
// 在一个类中可重复标注
@Repeatable(ComponentScans.class)
public @interface ComponentScan {
　
   // 定义扫描的包
   @AliasFor("basePackages")
   String[] value() default {};
   // 定义扫描的包
   @AliasFor("value")
   String[] basePackages() default {};
   // 定义扫描的类
   Class<?>[] basePackageClasses() default {};
　
   // Bean名称生成器
   Class<? extends BeanNameGenerator> nameGenerator()
      default BeanNameGenerator.class;
　
   // 作用域解析器
   Class<? extends ScopeMetadataResolver> scopeResolver()
      default AnnotationScopeMetadataResolver.class;
　
   // 作用域代理模式
   ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;
　
   // 资源匹配模式
   String resourcePattern() default
      ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;
　
   // 是否启用默认的过滤器
   boolean useDefaultFilters() default true;
　
   // 当满足过滤器的条件时扫描
   Filter[] includeFilters() default {};
　
   // 当不满足过滤器的条件时扫描
   Filter[] excludeFilters() default {};
　
   // 是否延迟初始化
   boolean lazyInit() default false;
　
   // 定义过滤器
   @Retention(RetentionPolicy.RUNTIME)
   @Target({})
   @interface Filter {
      // 过滤器类型，可以按注解类型或者正则式等过滤
      FilterType type() default FilterType.ANNOTATION;
      // 定义过滤的类
      @AliasFor("classes")
      Class<?>[] value() default {};
　
      // 定义过滤的类
      @AliasFor("value")
      Class<?>[] classes() default {};
　
      // 通过正则式匹配方式来扫描
      String[] pattern() default {};
   }
}
```

上述加粗的代码是最常用的配置项，需要了解它们的使用方法。
●basePackages：指定需要扫描的包名，如果不配置它或者包名为空，则只扫描当前包和其子包下的路径。●basePackageClasses：指定被扫描的类；
●includeFilters：指定满足过滤器(Filter)条件的类将会被IoC容器扫描、装配；
●excludeFilters：指定满足过滤器条件的类将不会被IoC容器扫描、装配。
●lazyInit：延迟初始化，这个配置项有点复杂，3.4节介绍Bean的生命周期时会再讨论它。includeFilters和excludeFilters这两个配置项都需要通过一个注解@Filter定义，这个注解有以下配置项。
●type：通过它可以选择通过注解或者正则式等进行过滤；
●classes：通过它可以指定通过什么注解进行过滤，只有被标注了指定注解的类才会被过滤；
●pattern：通过它可以定义过滤的正则式。
```java
@ComponentScan("com.learn.chapter3.*")

@ComponentScan(basePackages = {"com.learn.chapter3.pojo"})

@ComponentScan(basePackageClasses = {User.class})
```

###### 不被扫描
```java
@ComponentScan(basePackages = "com.learn.chapter3.*",
// type配置通过注解的方式进行过滤，classes指定通过什么注解进行过滤
excludeFilters = @Filter(type=FilterType.ANNOTATION, classes = Service.class))
```


#### 自定义第三方Bean
##### 例子
```xml
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
</dependency>
```

```java
// 注解@Bean表示需要将方法返回的对象装配到IoC容器中，name配置Bean名称
@Bean(name = "dataSource")
public DataSource getDataSource() {
   var dataSource = new MysqlDataSource();
   try {
      dataSource.setUrl("jdbc:mysql://localhost:3306/chapter3");
      dataSource.setUser("root");
      dataSource.setPassword("123456");
   } catch (Exception e) {
      e.printStackTrace();
   }
   return dataSource;
}
```

#### 依赖注入

##### 注解@Autowired
注意，@Autowired是一个默认必须找到对应Bean的注解，如果不能确定其标注属性一定会存在并且允许这个被标注的属性为null，那么可以配置@Autowired的required属性为false，例如：
``` java
@Autowired(required = false)
```

它除了可以标注属性，还可以标注方法，如setAnimal()方法：
```java
@Override
@Autowired
public void setAnimal(Animal animal) {
   this.animal = animal;
}
```

#### 消除歧义性——@Primary和@Qualifier
**@Primary**，它是一个修改优先权的注解。当既有猫、又有狗的时候，假设这次需要使用猫，那么只需要在猫类的定义上加入@Primary就可以了
```java
......
@Component
@Primary
public class Cat implements Animal {
   ......
}
```
在上述代码中，@Primary告诉IoC容器：​“当发现有多个同样类型的Bean时，请优先使用我进行注入。​”于是再次进行测试时会发现，系统将用猫提供服务。当Spring进行注入的时候，虽然发现存在多个动物，但因为Cat被标注为@Primary，所以优先采用Cat实例进行注入


**@Qualifier**的配置项value需要用一个字符串定义，它将与@Autowired组合在一起，通过名称和类型一起找到Bean。我们知道Bean名称在IoC容器中是唯一的标识，利用它就可以消除歧义性了。
```java
@Autowired
@Qualifier("dog")
private Animal animal = null;
```


#### 带有参数的构造方法类的装配
有些类只有带有参数的构造方法，于是@Autowired定义的方式不再适用了。
```java
package com.learn.chapter3.pojo;
　
/******** imports ********/
@Component
public class BussinessPerson implements Person {
   private Animal animal = null;
　
   public BussinessPerson(@Autowired @Qualifier("dog") Animal animal) {
      this.animal = animal;
   }
   @Override
   public void service() {
      this.animal.use();
   }
　
   @Override
   public void setAnimal(Animal animal) {
      this.animal = animal;
   }
　
}
```

#### 生命周期
(1)Spring通过我们的配置，到@ComponentScan定义的扫描路径中找到标注@Component的类，这个过程就是一个资源定位的过程。
(2)一旦找到了资源，Spring就会解析这些资源，并将其保存为Bean的定义(BeanDefinition)。注意，此时还没有初始化Bean，也就没有Bean的实例，有的仅仅是Bean的定义。
(3)把Bean的定义发布到IoC容器中。此时，IoC容器中装载的也只有Bean的定义，还没有生成Bean的实例。

![[Pasted image 20240826103440.png]]

```java
@ComponentScan(basePackages = "com.learn.chapter3.*", lazyInit = true)
```
Spring并不会在发布Bean定义后马上完成实例化和依赖注入，只有在获取Bean的时候，也就是运行getBean()方法时，Spring才会进行对Bean的实例化。
![[Pasted image 20240826103753.png]]